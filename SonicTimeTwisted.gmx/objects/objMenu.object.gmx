<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// States reference
/*
States available by default (ports to other platforms will extend this list):

0 - default state - see below
1 - main title screen
2 - level pause menu
3 - special stage pause menu
4 - special stage retry menu (out of rings)
5 - special stage retry menu (lost)
6 - special stage retry menu (off track)
7 - options
8 - control config - keyboard
9 - control config - gamepad
10 - confirmation screen
11 - level select - character select
12 - level select - zone select
13 - level select - attraction attack
14 - level select - raging ruins
15 - level select - frigid fortress
16 - level select - viridian valley
17 - level select - drifting dynamo
18 - level select - tidal tubes
19 - level select - planetary panic

*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// if there's already a menu present: don't create this
/*
if(instance_number(objMenu) &gt; 1)
{
    // create this here so that the obj destroy event doesn't glitch
    temp_map = ds_map_create();
    instance_destroy();
}
else
{
*/
    active = false;
    
    state = 0;
    default_state = 2;
    
    cursor = 0;
    max_cursor = 0;
    
    options = false;
    options_initialized = false;
    
    // if true, the title is displayed for a couple of seconds before the menu proper
    // example: special stages
    delay_timer = 0;
    delay_timer_default = 60;
    
    // flash timer - flashing when an option is selected before executing it
    flash_timer = 0;
    
    // slide timer - slide from one option screen to another
    slide_timer = 0;
    slide_dir = false; // false = left, true = right
    slide_to_state = 0;
    slide_to_cursor = 0;
    slide_from_state = 0;
    slide_x_shift = 0;
    
    // for options that must be constantly flashing (yes, those sometimes exist)
    // this flag is used to determine whether they should be drawn 
    flash_on = false;
    
    // the menu is supposed to be centered - calculate the Y offset needed to do so
    menu_y_offset = 0;
    
    
    // if true, add view offsets to the draw coordinates
    draw_with_view_offset = true;
    
    // 
    large = false;
    
    back_state = 0;
    back_cursor = 0;
    use_default_interface = true;
    
    allow_input = true;
    wait_for_release = false;
    
    // this variable might be useful in particular cases, such as remapping keys
    substate = 0; 
    // this will be very useful for key mappings
    temp_map = ds_map_create();
    // axis - well, looks like this is necessary for being able to detect axis mappings
    axis = "";
    wait_for_release_axis = false;
    // in case we want a confirmation screen ; these variables will store the state
    // and cursor which demanded to display it
    confirm_state = 0;
    confirm_cursor = 0;
    confirm_animation = 0;
    confirm_text = 0;
    // draw offset variables - could have been "var", but inheriting objects might want to use those
    x_offset = 0;
    y_offset = 0;
    // pressed key: used to manage left/right presses
    pressed = false;
//}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_map_destroy(temp_map);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="17">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>menu_key_mapping_states();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="16">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// special draw for some states - overrideable
if(state == 11)
{
    // draw character select sprites
    if(cursor == 8)
    {
        draw_sprite(sprCharacterSelect, 1, x_offset+96, view_yview[view_current] + 112);
        draw_sprite(sprSelector, 1, x_offset+96, view_yview[view_current] + 112);
    }
    else
    {
        draw_sprite_ext(sprCharacterSelect, 1, x_offset+96, view_yview[view_current] + 112, 1, 1, 0, c_white, 0.5);
    }
    if(cursor == 9)
    {
        draw_sprite(sprCharacterSelect, 0, x_offset+216, view_yview[view_current] + 112);
        draw_sprite(sprSelector, 0, x_offset+216, view_yview[view_current] + 112);
    }
    else
    {
        draw_sprite_ext(sprCharacterSelect, 0, x_offset+216, view_yview[view_current] + 112, 1, 1, 0, c_white, 0.5);
    }
    if(cursor == 10)
    {
        draw_sprite(sprCharacterSelect, 2, x_offset+336, view_yview[view_current] + 112);
        draw_sprite(sprSelector, 2, x_offset+336, view_yview[view_current] + 112);
    }
    else
    {
        draw_sprite_ext(sprCharacterSelect, 2, x_offset+336, view_yview[view_current] + 112, 1, 1, 0, c_white, 0.5);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="15">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// processing a click or a confirm key press - code reusable inside of this object
if(cursor &lt; array_height_2d(options) &amp;&amp; !(cursor == 0 &amp;&amp; options[0, OPTION_TYPE] == OPTION_TYPE_TITLE))
{
    if(options[cursor, OPTION_TYPE] == OPTION_TYPE_SUBMENU)
    {
        audio_play_sound(sndBeep,10,false);
        slide_dir = true;
        slide_timer = 30;
        slide_to_state = real(options[cursor, OPTION_VALUE]);
        slide_to_cursor = 0;
        slide_from_state = state;
    }
    else
    if(options[cursor, OPTION_TYPE] == OPTION_TYPE_RETURN)
    {
        audio_play_sound(sndBeep,10,false);
        slide_dir = false;
        slide_timer = 30;
        if(state != 10)
        {
            slide_to_state = real(options[cursor, OPTION_VALUE]);
            slide_to_cursor = 0;
            slide_from_state = state;
        }
        else
        {
            slide_to_state = confirm_state;
            slide_to_cursor = confirm_cursor;
            slide_from_state = 10;
        }
    }
    else
    if(options[cursor, OPTION_TYPE] == OPTION_TYPE_CONFIRM)
    {
        audio_play_sound(sndBeep,10,false);
        slide_dir = true;
        slide_timer = 30;
        slide_to_state = 10;
        slide_to_cursor = 0;
        slide_from_state = state;
        
        confirm_state = state;
        confirm_cursor = cursor;
        confirm_animation = options[cursor, OPTION_ANIMATION];
        confirm_text = options[cursor, OPTION_VALUE];
    }
    else
    {
        if(options[cursor, OPTION_ANIMATION] == OPTION_ANIMATION_LONGPRESS)
        {
            audio_play_sound(sndLampPost,10,false);
            flash_timer = 30;
        }
        else
        {
            audio_play_sound(sndBeep,10,false);
            event_user(2);
        }
    }
}
else
{
    audio_play_sound(sndBeep,10,false);
    event_user(2);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw - called by parent object
if(active)
{
    x_offset = slide_x_shift;
    y_offset = menu_y_offset;
    if(draw_with_view_offset)
    {
        x_offset += view_xview[view_current];
        y_offset += view_yview[view_current];
    }

    
    draw_set_color(c_yellow);
    
    for(var i = 0; i &lt; array_height_2d(options); i++)
    {
        var line_visible = true;
        if(delay_timer &gt; 0)
        {
            if(options[i, OPTION_TYPE] != OPTION_TYPE_TITLE)
            {
                line_visible = false;
            }
        }
        else
        {
            if(cursor == i)
            {
                if(large)
                {
                    draw_sprite_ext(sprSelectLong,image_index,x_offset+213, y_offset+20*i+6,1,1,0,c_white,1);
                }
                else
                {
                    draw_sprite_ext(sprLevelSelect,image_index,x_offset+213, y_offset+20*i+6,1,1,0,c_white,1);
                }
                
                if(flash_timer &gt; 0)
                {
                    // Usually, 30 FPS mode would be managed more elegantly (by managing flashing in a draw begin event) but here, it's more difficult.
                    // So specific code it is.
                    if(instance_exists(objFramerate))
                    {
                        line_visible = (flash_timer mod 4) &lt;= 1;
                    }
                    else
                    {
                        line_visible = (flash_timer mod 2) == 0;
                    }
                }
            }
        }
        if(line_visible &amp;&amp; (options[i, OPTION_ANIMATION] != OPTION_ANIMATION_FLASHING || flash_on))
        {
            var color = c_yellow;
            if(options[i, OPTION_TYPE] == OPTION_TYPE_TITLE)
            {
                color = c_gray;
            }
            if(options[i, OPTION_TYPE] == OPTION_TYPE_WITH_VALUE)
            {
                if(large)
                {
                    draw_set_halign(fa_left);
                    draw_text_color(x_offset+213 - 170, y_offset+20*i, options[i, OPTION_NAME],c_white,c_white,color,color,1);
                    draw_set_halign(fa_right);
                    draw_text_color(x_offset+213 + 170, y_offset+20*i, options[i, OPTION_VALUE],c_white,c_white,color,color,1);
                }
                else
                {
                    draw_set_halign(fa_left);
                    draw_text_color(x_offset+213 - 100, y_offset+20*i, options[i, OPTION_NAME],c_white,c_white,color,color,1);
                    draw_set_halign(fa_right);
                    draw_text_color(x_offset+213 + 100, y_offset+20*i, options[i, OPTION_VALUE],c_white,c_white,color,color,1);
                }
            }
            else
            {
                draw_set_halign(fa_center);
                draw_text_color(x_offset+213, y_offset+20*i, options[i, OPTION_NAME],c_white,c_white,c_yellow,c_yellow,1);
            }

        }
    }
    if(state == 11)
    {
        // draw character select sprites
        event_user(6);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// what to do when left or right are pushed
var activated = false;
if(active)
{
    switch(state)
    {
        case 7:
            switch(cursor)
            {
                case 2: // gamepad enabled/disabled
                    with(objProgram.inputManager)
                    {
                        event_user(0);
                    }
                    event_user(1);
                    activated = true;
                    break;
            }
            break;
        case 20:
            switch(cursor)
            {
                case 1: // screen size
                    if(pressed == cLEFT)
                    {
                        set_video_mode((get_video_mode() + 4 - 1) mod 4);
                        event_user(1);
                    }
                    else
                    {
                        set_video_mode((get_video_mode() + 1) mod 4);
                        event_user(1);
                    }
                    break;
                case 2: // framerate
                    set_30_fps(1 - get_30_fps());
                    event_user(1);
                    break;
                case 3: // score tally mode
                    if(pressed == cLEFT)
                    {
                        if(objProgram.score_tally_mode)
                        {
                            objProgram.score_tally_mode--;
                        }
                        else
                        {
                            objProgram.score_tally_mode = 2;
                        }
                    }
                    else
                    {
                        objProgram.score_tally_mode = (objProgram.score_tally_mode + 1) mod 3;
                    }
                    save_options();
                    event_user(1);
                    activated = true;
                    break;
            }
            break;
    }
}
if(activated)
{
    audio_play_sound(sndBeep,10,false);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Execute actions when option is selected - called by this object

var usedState = state;
var usedCursor = cursor;
// if we're currently confirming a selection: use the action asociated with the
// object that asked for confirmation, not the one associated with the
// "confirm" option
if(state == 10 &amp;&amp; cursor == 1)
{
    usedState = confirm_state;
    usedCursor = confirm_cursor;
}

if(active)
{
    switch(usedState)
    {
        case 1:
            // Title screen
            switch(usedCursor)
            {
                case 0: // Play
                    transition_to(objFadeWhite, saveSelect, 10);
                break;
                case 2: // Quit
                    game_end();
                break;
            }
            break;
        case 2:
            // Game pause menu
            switch(usedCursor)
            {
                case 0: // Resume
                    objProgram.paused = false;
                    game_pause(objProgram.paused);
                    active = false;
                break;
                case 2: // Restart
                     game_restart();
                break;
            }
            break;
        case 3:
            // Game pause menu - special stage
            switch(usedCursor)
            {
                case 0: // Resume
                    objProgram.paused = false;
                    game_pause(objProgram.paused);
                    active = false;
                break;
                case 2: // Restart
                     game_restart();
                break;
            }
            break;
        case 4:
        case 5:
        case 6:
            // Special stage failure menu
            if(objProgram.saveSlot == -1) // if we are playing this in the mini-game/level select mode, this menu behaves differently
            {
                switch(usedCursor)
                {
                    case 1: // restart
                        room_restart();
                        with objSSLevel loopMusic = true;
                }
            }
            else
            {
                switch(usedCursor)
                {
                    case 1: // Return to act if no lives left; restart if lives left
                        if(objGameData.player_lives[0] &gt; 1)
                        {
                            objGameData.player_lives[0] -= 1;
                            save_lives(objGameData.player_lives[0]);
                            room_restart();
                            with objSSLevel loopMusic = true;
                        }
                        else
                        {
                            with(objSSHud)
                            {
                                closeMenu = true;
                            }
                            active = false;
                            stop_all_music(false);
                            level_goback();
                        }
                    break;
                    case 2: // Return to act
                        with(objSSHud)
                        {
                            closeMenu = true;
                        }
                        active = false;
                        stop_all_music(false);
                        level_goback();
                    break;
                }
            }
            break;
        case 7:
            // Options menu
            switch(usedCursor)
            {
                case 2: // gamepad enabled/disabled
                    with(objProgram.inputManager)
                    {
                        event_user(0);
                    }
                    event_user(1);
                    break;
            }
            
            break;
        case 8:
        case 9:
            switch(usedCursor)
            {
                // key mapping screen
                case 1:
                    // Remap all
                    substate = 2;
                    break;
                case 2:
                    // Remap up
                case 3:
                    // Remap down
                case 4:
                    // Remap left
                case 5:
                    // Remap right
                case 6:
                    // Remap A
                case 7:
                    // Remap B
                case 8:
                    // Remap C
                case 9:
                    // Remap start
                    substate = usedCursor;
                    break;
            }
            use_default_interface = false;
            event_user(1);
            break;
        case 11:
            use_default_interface = true;
            // level select - character
            switch(usedCursor)
            {
                case 8:
                case 9:
                case 10:
                    switch(usedCursor)
                    {
                        case 8:
                            substate = 2;
                            break;
                        case 9:
                            substate = 1;
                            break;
                        case 10:
                            substate = 3;
                            break;
                    }
                    objGameData.character_id[0] = substate;
                    audio_play_sound(sndBeep,10,false);
                    slide_dir = true;
                    slide_timer = 30;
                    slide_to_state = 12;
                    slide_to_cursor = 1;
                    slide_from_state = state;
                break;
                default:
                    audio_play_sound(sndBeep,10,false);
                    slide_dir = false;
                    slide_timer = 30;
                    slide_to_state = default_state;
                    slide_to_cursor = 0;
                    slide_from_state = state;
            }
            break;
        case 12:
            // Zone select - only two zones are directly selectable here
            objProgram.saveSlot = 0;
            switch(usedCursor)
            {
                case 7: // Sunken saucer
                    objProgram.current_level=12;
                    objProgram.in_past = false;
                    level_goto_next()
                    break;
                case 9: // Galacnik Gauntlet
                    objProgram.current_level=15;
                    objProgram.in_past = false;
                    level_goto_next();
                    break;
                case 10: // Special stages - need to force substate
                    audio_play_sound(sndBeep,10,false);
                    slide_dir = true;
                    slide_timer = 30;
                    slide_to_state = 21;
                    slide_to_cursor = 1;
                    slide_from_state = state;
                    substate = 0;
                    break;
            }
            break;
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
            // regular stages
            objProgram.saveSlot = 0;
            objProgram.in_past = usedCursor mod 2 == 0;
            var curLevel = (usedState - 13) * 2;
            if(usedCursor &gt; 2)
            {
                curLevel++;
            }
            if(curLevel &gt; 0)
            {
                objProgram.current_level=curLevel;
            }
            level_goto_next();
            break;
        case 19:
            objProgram.saveSlot = 0;
            objProgram.in_past = false;
            if(usedCursor == 1)
            {
                objProgram.current_level=13;
                level_goto_next()
            }
            else
            {
                objProgram.current_level=14;
                level_goto_next()
            }
            break;
        case 20:
            // Video options menu
            switch(usedCursor)
            {
                case 1: // screen size
                    set_video_mode((get_video_mode() + 1) mod 4);
                    event_user(1);
                    break;
                case 2: // framerate
                    set_30_fps(1 - get_30_fps());
                    event_user(1);
                    break;
                case 3: // score tally mode
                    objProgram.score_tally_mode = (objProgram.score_tally_mode + 1) mod 3;
                    save_options();
                    event_user(1);
                    break;
            }
            
            break;
        case 22:
        case 23:
            // level select - special stages
            special_level_go_to_from_level_select(state == 22, usedCursor);           
            break;
        case 24:
        case 25:
            // special stages in level select mode
            switch(usedCursor)
            {
                case 1: // select another - could be a simple submenu, but substate has to be managed too
                    audio_play_sound(sndBeep,10,false);
                    slide_dir = true;
                    slide_timer = 30;
                    slide_to_state = 21;
                    slide_to_cursor = 1;
                    slide_from_state = state;
                    substate = 1;
                    if(state == 25)
                    {
                        substate = 2;
                    }
                    break;
                case 2: // restart game
                    game_restart();
                    
            }
            break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init available options for every state - called by this object

options = false;
//use_default_interface = true;
large = false;
if(state == 0)
{
   state = default_state;
}
switch(state)
{
    case 1:
        options[0, OPTION_NAME] = 'PLAY';
        options[0, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[1, OPTION_NAME] = 'OPTIONS';
        options[1, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[1, OPTION_VALUE] = 7;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[2, OPTION_NAME] = 'EXIT GAME';
        options[2, OPTION_TYPE] = OPTION_TYPE_CONFIRM;
        options[2, OPTION_VALUE] = 'EXIT GAME';
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        break;
    case 2:
    case 3:
        options[0, OPTION_NAME] = 'CONTINUE';
        options[0, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[1, OPTION_NAME] = 'OPTIONS';
        options[1, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[1, OPTION_VALUE] = 7;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[2, OPTION_NAME] = 'RESTART GAME';
        options[2, OPTION_TYPE] = OPTION_TYPE_CONFIRM;
        options[2, OPTION_VALUE] = "ALL UNSAVED PROGRESS WILL BE LOST";
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        break;
    case 4:
    case 5:
    case 6:
        var title = "";
        
        switch(state)
        {
            case 4:
                title = 'OUT OF RINGS';
                break;
            case 5:
                title = 'OFF TRACK';
                break;
            case 6:
                title = '';
                break;
        }
        options[0, OPTION_NAME] = title;
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        if(objProgram.saveSlot == -1) // if we are playing this in the mini-game/level select mode, this menu behaves differently
        {
                options[1, OPTION_NAME] = 'TRY AGAIN';
                options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
                options[1, OPTION_VALUE] = false;
                options[1, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
                options[2, OPTION_NAME] = 'FORFEIT';
                options[2, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
                options[2, OPTION_VALUE] = 24;
                options[2, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        }
        else
        {
            if(objGameData.player_lives[0] &gt; 1)
            {
                options[1, OPTION_NAME] = 'TRY AGAIN z1 LIFE';
                options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
                options[1, OPTION_VALUE] = false;
                options[1, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
                options[2, OPTION_NAME] = 'RETURN TO ACT';
                options[2, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
                options[2, OPTION_VALUE] = false;
                options[2, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
            }
            else
            {
                options[1, OPTION_NAME] = 'RETURN TO ACT';
                options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
                options[1, OPTION_VALUE] = false;
                options[1, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
            }
        }
        break;
    case 7:
        large = true;
        
        var gamepadStateLabel = "NO";
        if(objProgram.inputManager.gamepad_update_enabled)
        {
            gamepadStateLabel = "YES";
        }
    
        options[0, OPTION_NAME] = 'OPTIONS';
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = '';
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[1, OPTION_NAME] = 'VIDEO OPTIONS';
        options[1, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[1, OPTION_VALUE] = 20;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[2, OPTION_NAME] = 'ENABLE GAMEPAD';
        options[2, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[2, OPTION_VALUE] = gamepadStateLabel;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[3, OPTION_NAME] = 'MAP KEYS';
        options[3, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[3, OPTION_VALUE] = 8;
        options[3, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[4, OPTION_NAME] = 'MAP GAMEPAD';
        options[4, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[4, OPTION_VALUE] = 9;
        options[4, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[5, OPTION_NAME] = 'BACK';
        options[5, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[5, OPTION_VALUE] = 0;
        options[5, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        break;
    case 8:
    case 9:
        var upLabel = 0;
        var downLabel = 0;
        var leftLabel = 0;
        var rightLabel = 0;
        var aLabel = 0;
        var bLabel = 0;
        var cLabel = 0;
        var startLabel = 0;
        if(state == 8)
        {
            for(var i=0; i &lt; objProgram.inputManager.key_count; i++)
            {
                var stored_key;
                if(ds_map_exists(temp_map, objProgram.inputManager.key_control[i]))
                {
                    stored_key = ds_map_find_value(temp_map, objProgram.inputManager.key_control[i]);
                }
                else
                {
                    stored_key = objProgram.inputManager.key[i];
                }
                switch(objProgram.inputManager.key_control[i])
                {
                    case cUP:
                        upLabel = get_kb_label(stored_key);
                        break;
                    case cDOWN:
                        downLabel = get_kb_label(stored_key);
                        break;
                    case cLEFT:
                        leftLabel = get_kb_label(stored_key);
                        break;
                    case cRIGHT:
                        rightLabel = get_kb_label(stored_key);
                        break;
                    case cA:
                        aLabel = get_kb_label(stored_key);
                        break;
                    case cB:
                        bLabel = get_kb_label(stored_key);
                        break;
                    case cC:
                        cLabel = get_kb_label(stored_key);
                        break;
                    case cSTART:
                        startLabel = get_kb_label(stored_key);
                        break;
                }
            }
        }
        else
        {
            for(var i=0; i &lt; objProgram.inputManager.button_count; i++)
            {
                var stored_key;
                if(ds_map_exists(temp_map, objProgram.inputManager.button_control[i]))
                {
                    stored_key = ds_map_find_value(temp_map, objProgram.inputManager.button_control[i]);
                }
                else
                {
                    stored_key = objProgram.inputManager.button[i];
                }
                switch(objProgram.inputManager.button_control[i])
                {
                    case cUP:
                        upLabel = get_gp_label(stored_key);
                        break;
                    case cDOWN:
                        downLabel = get_gp_label(stored_key);
                        break;
                    case cLEFT:
                        leftLabel = get_gp_label(stored_key);
                        break;
                    case cRIGHT:
                        rightLabel = get_gp_label(stored_key);
                        break;
                    case cA:
                        aLabel = get_gp_label(stored_key);
                        break;
                    case cB:
                        bLabel = get_gp_label(stored_key);
                        break;
                    case cC:
                        cLabel = get_gp_label(stored_key);
                        break;
                    case cSTART:
                        startLabel = get_gp_label(stored_key);
                        break;
                }
            }
            for(var i=0; i &lt; objProgram.inputManager.axis_count; i++)
            {
                var stored_key;
                if(ds_map_exists(temp_map, objProgram.inputManager.axis_control[i]))
                {
                    stored_key = ds_map_find_value(temp_map, objProgram.inputManager.axis_control[i]);
                }
                else
                {                
                    var axiscode = "+";
                    if(objProgram.inputManager.axis_direction[i] &lt; 0)
                    {
                        axiscode = "-";
                    }
                    axiscode += string(objProgram.inputManager.axis[i]);
                    stored_key = axiscode;
                }
                
                switch(objProgram.inputManager.axis_control[i])
                {
                    case cUP:
                        upLabel = get_gp_label(stored_key);
                        break;
                    case cDOWN:
                        downLabel = get_gp_label(stored_key);
                        break;
                    case cLEFT:
                        leftLabel = get_gp_label(stored_key);
                        break;
                    case cRIGHT:
                        rightLabel = get_gp_label(stored_key);
                        break;
                    case cA:
                        aLabel = get_gp_label(stored_key);
                        break;
                    case cB:
                        bLabel = get_gp_label(stored_key);
                        break;
                    case cC:
                        cLabel = get_gp_label(stored_key);
                        break;
                    case cSTART:
                        startLabel = get_gp_label(stored_key);
                        break;
                }
            }
        }
        
        var pressCancelMessage = "PRESS "+objProgram.back_button_label+" TO CANCEL";
        
        options[0, OPTION_NAME] = 'MAP KEYS';
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        if(state == 9)
        {
            options[0, OPTION_NAME] = 'MAP GAMEPAD';
        }
        
        options[1, OPTION_NAME] = 'REMAP ALL';
        options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[1, OPTION_VALUE] = false;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[2, OPTION_NAME] = 'UP';
        options[2, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[2, OPTION_VALUE] = upLabel;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[3, OPTION_NAME] = 'DOWN';
        options[3, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[3, OPTION_VALUE] = downLabel;
        options[3, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[4, OPTION_NAME] = 'LEFT';
        options[4, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[4, OPTION_VALUE] = leftLabel;
        options[4, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[5, OPTION_NAME] = 'RIGHT';
        options[5, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[5, OPTION_VALUE] = rightLabel;
        options[5, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[6, OPTION_NAME] = 'A';
        options[6, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[6, OPTION_VALUE] = aLabel;
        options[6, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[7, OPTION_NAME] = 'B';
        options[7, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[7, OPTION_VALUE] = bLabel;
        options[7, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[8, OPTION_NAME] = 'C';
        options[8, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[8, OPTION_VALUE] = cLabel;
        options[8, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[9, OPTION_NAME] = 'START';
        options[9, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[9, OPTION_VALUE] = startLabel;
        options[9, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        if(!use_default_interface)
        {
            if(substate &gt;= 2 &amp;&amp; substate &lt;= 10)
            {
                options[cursor, OPTION_NAME] = pressCancelMessage;
                options[substate, OPTION_ANIMATION] = OPTION_ANIMATION_FLASHING;
                options[substate, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
            }
        }
        
        options[10, OPTION_NAME] = 'BACK';
        options[10, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[10, OPTION_VALUE] = 7;
        options[10, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        break;
    case 10:
        options[0, OPTION_NAME] = confirm_text;
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[1, OPTION_NAME] = 'CONFIRM';
        options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[1, OPTION_VALUE] = false;
        options[1, OPTION_ANIMATION] = confirm_animation;
        
        options[2, OPTION_NAME] = 'CANCEL';
        options[2, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[2, OPTION_VALUE] = confirm_state;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        break;
    case 11:
        // level select - character select : this screen is very different
        substate = 0;
        options[0, OPTION_NAME] = 'CHARACTER SELECT';
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[1, OPTION_NAME] = '';
        options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[1, OPTION_VALUE] = false;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[2, OPTION_NAME] = '';
        options[2, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[2, OPTION_VALUE] = false;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[3, OPTION_NAME] = '';
        options[3, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[3, OPTION_VALUE] = false;
        options[3, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[4, OPTION_NAME] = '';
        options[4, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[4, OPTION_VALUE] = false;
        options[4, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[5, OPTION_NAME] = 'BACK';
        options[5, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[5, OPTION_VALUE] = false;
        options[5, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        cursor = 9;
        use_default_interface = false;
        break;
    case 12:
        // level select - zone select
        use_default_interface = true;
        options[0, OPTION_NAME] = 'ZONE SELECT';
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[1, OPTION_NAME] = 'ATTRACTION ATTACK ZONE';
        options[1, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[1, OPTION_VALUE] = 13;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[2, OPTION_NAME] = 'RAGING RUINS ZONE';
        options[2, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[2, OPTION_VALUE] = 14;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[3, OPTION_NAME] = 'FRIGID FORTRESS ZONE';
        options[3, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[3, OPTION_VALUE] = 15;
        options[3, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[4, OPTION_NAME] = 'VIRIDIAN VALLEY ZONE';
        options[4, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[4, OPTION_VALUE] = 16;
        options[4, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[5, OPTION_NAME] = 'DRIFTING DYNAMO ZONE';
        options[5, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[5, OPTION_VALUE] = 17;
        options[5, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[6, OPTION_NAME] = 'TIDAL TUBES ZONE';
        options[6, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[6, OPTION_VALUE] = 18;
        options[6, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[7, OPTION_NAME] = 'SUNKEN SAUCER ZONE';
        options[7, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[7, OPTION_VALUE] = false;
        options[7, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[8, OPTION_NAME] = 'PLANETARY PANIC ZONE';
        options[8, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[8, OPTION_VALUE] = 19;
        options[8, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[9, OPTION_NAME] = 'GALACNIK GAUNTLET ZONE';
        options[9, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[9, OPTION_VALUE] = false;
        options[9, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[10, OPTION_NAME] = 'SPECIAL STAGES';
        options[10, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[10, OPTION_VALUE] = false;
        options[10, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[11, OPTION_NAME] = 'BACK';
        options[11, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[11, OPTION_VALUE] = 11;
        options[11, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        break;
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
        var title = '';
        switch(state)
        {
            case 13:
                title = 'ATTRACTION ATTACK ZONE';
                break;
            case 14:
                title = 'RAGING RUINS ZONE';
                break;
            case 15:
                title = 'FRIGID FORTRESS ZONE';
                break;
            case 16:
                title = 'VIRIDIAN VALLEY ZONE';
                break;
            case 17:
                title = 'DRIFTING DYNAMO ZONE';
                break;
            case 18:
                title = 'TIDAL TUBES ZONE';
                break;
        }
        options[0, OPTION_NAME] = title+'  ACT SELECT';
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[1, OPTION_NAME] = 'ACT 1 FUTURE';
        options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[1, OPTION_VALUE] = false;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[2, OPTION_NAME] = 'ACT 1 PAST';
        options[2, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[2, OPTION_VALUE] = false;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[3, OPTION_NAME] = 'ACT 2 FUTURE';
        options[3, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[3, OPTION_VALUE] = false;
        options[3, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[4, OPTION_NAME] = 'ACT 2 PAST';
        options[4, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[4, OPTION_VALUE] = false;
        options[4, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[5, OPTION_NAME] = 'BACK';
        options[5, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[5, OPTION_VALUE] = 12;
        options[5, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        break;
    case 19:
        var title = 'PLANETARY PANIC ZONE';
        options[0, OPTION_NAME] = title+'  ACT SELECT';
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[1, OPTION_NAME] = 'ACT 1';
        options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[1, OPTION_VALUE] = false;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[2, OPTION_NAME] = 'ACT 2';
        options[2, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[2, OPTION_VALUE] = false;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[3, OPTION_NAME] = 'BACK';
        options[3, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[3, OPTION_VALUE] = 12;
        options[3, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        break;
    case 20:
        // Video options - added later, hence the ID
        
        large = true;
        
        var screenStateLabel = "FULLSCREEN";
        switch get_video_mode() {
            case 0:
                screenStateLabel = "WINDOW";
            break;
            case 1:
                screenStateLabel = "WINDOW 2X";
            break;
            case 2:
                screenStateLabel = "WINDOW 3X";
            break;
            case 3:
                screenStateLabel = "FULLSCREEN";
            break;
        }
        
        var frameRateLabel = "60 FPS";
        switch get_30_fps() {
            case 1:
                frameRateLabel = "30 FPS";
            break;
        }
        
        var tallyLabel = "RANDOM DIGITS";
        switch(objProgram.score_tally_mode)
        {
            case 1:
                tallyLabel = "VARIABLE SPEED";
                break;
            case 2:
                tallyLabel = "CONSTANT SPEED";
                break;
        }
        
        options[0, OPTION_NAME] = 'VIDEO OPTIONS';
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[1, OPTION_NAME] = 'SCREEN SIZE';
        options[1, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[1, OPTION_VALUE] = screenStateLabel;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[2, OPTION_NAME] = 'FRAMERATE';
        options[2, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[2, OPTION_VALUE] = frameRateLabel;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[3, OPTION_NAME] = 'SCORE TALLY MODE';
        options[3, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[3, OPTION_VALUE] = tallyLabel;
        options[3, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[4, OPTION_NAME] = 'BACK';
        options[4, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[4, OPTION_VALUE] = 7;
        options[4, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        break;
    case 21:
        // stage select - special stages
        options[0, OPTION_NAME] = 'SPECIAL STAGES';
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[1, OPTION_NAME] = 'PAST';
        options[1, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[1, OPTION_VALUE] = 22;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[2, OPTION_NAME] = 'FUTURE';
        options[2, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[2, OPTION_VALUE] = 23;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[3, OPTION_NAME] = 'BACK';
        options[3, OPTION_TYPE] = OPTION_TYPE_RETURN;
        switch(substate)
        {
            case 1:
                options[3, OPTION_VALUE] = 24;
                options[0, OPTION_NAME] = 'TRY ANOTHER SPECIAL STAGE';
                break;
            case 2:
                options[3, OPTION_VALUE] = 25;
                options[0, OPTION_NAME] = 'TRY ANOTHER SPECIAL STAGE';
                break;
            default:
                options[3, OPTION_VALUE] = 12;
                break;
        }
        options[3, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        break;
    case 22:
        // selecting a special stage in the past
    case 23:
        // selecting a special stage in the future
        var periodLabel = 'PAST';
        if(state == 23)
        {
            periodLabel = 'FUTURE';
        }
        
        options[0, OPTION_NAME] = periodLabel+ ' '+'SPECIAL STAGES';
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        for(var i = 1; i &lt;= 7; i++)
        {
            options[i, OPTION_NAME] = 'SPECIAL STAGE '+string(i);
            options[i, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
            options[i, OPTION_VALUE] = false;
            options[i, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        }
        options[8, OPTION_NAME] = 'BACK';
        options[8, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[8, OPTION_VALUE] = 21;
        options[8, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        break;
    case 24:
        // failing the special stage in minigame mode
    case 25:
        // completing the special stage in minigame mode
        var titleLabel = 'SPECIAL STAGE FORFEITED';
        if(state == 25)
        {
            titleLabel = 'SPECIAL STAGE COMPLETED';
        }
        
        options[0, OPTION_NAME] = titleLabel;
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;

        options[1, OPTION_NAME] = 'SELECT ANOTHER';
        options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[1, OPTION_VALUE] = false;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[2, OPTION_NAME] = 'RESTART GAME';
        options[2, OPTION_TYPE] = OPTION_TYPE_CONFIRM;
        options[2, OPTION_VALUE] = "LEVEL SELECT CODE WILL BE INACTIVE";
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        
        break;
    default:
        options[0, OPTION_NAME] = 'STATE DOES NOT EXIST';
        options[0, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        break;
        
}
// calculating the Y offset
max_cursor = array_height_2d(options) - 1;
menu_y_offset = floor((view_hview[view_current] - 20 * array_height_2d(options))/2);

options_initialized = true;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// step - called by parent object

if(active)
{
    // there is no such thing as default state - a default state must be a context-specific one
    if(state == 0)
    {
       state = default_state;
    }
    
    if(!options_initialized)
    {
        event_user(1);
    }
    if(wait_for_release)
    {
        if (!input_check(cSTART))
        {
            wait_for_release = false;
        }
    }
    else
    {
        if(use_default_interface)
        {
            /*
            Here, this is the code responsible for how the menu
            regularly operates
            
            */
            if(cursor == 0)
            {
                // if it's a menu title, it's not supposed to be selectable
                if (options[0, OPTION_TYPE] == OPTION_TYPE_TITLE)
                {
                    cursor = 1;
                }
            }
            // Input is only allowed if no animation is playing
            allow_input = (flash_timer == 0) &amp;&amp; (slide_timer == 0) &amp;&amp; (delay_timer == 0);
            if(allow_input)
            {
                // moving up, looping if necessary, skipping the title if there's one
                if input_check_pressed(cUP) {
                    audio_play_sound(sndBeep,10,false);
                    cursor--;
                    if(cursor == 0)
                    {
                        if(options[0, OPTION_TYPE] == OPTION_TYPE_TITLE)
                        {
                            cursor = max_cursor;
                        }
                    }
                    if(cursor &lt; 0)
                    {
                        cursor = max_cursor;
                    }
                }
                
                // moving down, looping if necessary, skipping the title if there's one
                if input_check_pressed(cDOWN) {
                    audio_play_sound(sndBeep,10,false);
                    cursor++;
                    if(cursor &gt; max_cursor)
                    {
                        cursor = 0;
                        if(options[0, OPTION_TYPE] == OPTION_TYPE_TITLE)
                        {
                            cursor = 1;
                        }
                    }
                }
                
                // activating the seleted item
                if input_check_pressed(cCONFIRM) {
                    event_user(5);
                }
                
                // what happens when left or right is pressed
                if input_check_pressed(cLEFT) {
                    pressed = cLEFT;
                    event_user(3);
                }
                if input_check_pressed(cRIGHT) {
                    pressed = cRIGHT;
                    event_user(3);
                }
                
                // if we want to cancel, the "back" menu item is found and activated
                if input_check_pressed(cCANCEL) {
                    for(var i = 0; i &lt;= max_cursor; i++)
                    {
                        if(options[i, OPTION_TYPE] == OPTION_TYPE_RETURN)
                        {
                            cursor = i;
                            event_user(5);
                            break;
                        }
                    }
                }
            }
            else
            {
                if(flash_timer &gt; 0)
                {
                    // some items play a flashing animation before activating
                    flash_timer--;
                    if(flash_timer == 0)
                    {
                        event_user(2);
                    }
                }
                else
                if(slide_timer &gt; 0)
                {
                    // this is the animation that plays when sliding between option screens
                    slide_timer--;
                    if(slide_timer == 15)
                    {
                        state = slide_to_state;
                        cursor = slide_to_cursor;
                        event_user(1);
                        for(var i = 0; i &lt; max_cursor; i++)
                        {
                            if(options[i, OPTION_TYPE] == OPTION_TYPE_SUBMENU)
                            {
                                if(options[i, OPTION_VALUE] == slide_from_state)
                                {
                                    cursor = i;
                                }
                            }
                        }
                    }
                    var diffxperframe = view_wview[view_current] / 15;
                    if(slide_timer &gt; 15)
                    {
                        slide_x_shift = -1 * diffxperframe * (30 - slide_timer);
                    }
                    else
                    {
                        slide_x_shift = diffxperframe * slide_timer;
                    }
                    if(!slide_dir)
                    {
                        slide_x_shift *= -1;
                    }
                }
                else
                if(delay_timer &gt; 0)
                {
                    // this is just for the special stage failure menus where a title must be shown for a bit before the rest
                    delay_timer--;
                }
            }
        }
        else
        {

            if(slide_timer &gt; 0)
            {
                // this is the animation that plays when sliding between option screens
                slide_timer--;
                if(slide_timer == 15)
                {
                    state = slide_to_state;
                    cursor = slide_to_cursor;
                    event_user(1);
                    for(var i = 0; i &lt; max_cursor; i++)
                    {
                        if(options[i, OPTION_TYPE] == OPTION_TYPE_SUBMENU)
                        {
                            if(options[i, OPTION_VALUE] == slide_from_state)
                            {
                                cursor = i;
                            }
                        }
                    }
                }
                var diffxperframe = view_wview[view_current] / 15;
                if(slide_timer &gt; 15)
                {
                    slide_x_shift = -1 * diffxperframe * (30 - slide_timer);
                }
                else
                {
                    slide_x_shift = diffxperframe * slide_timer;
                }
                if(!slide_dir)
                {
                    slide_x_shift *= -1;
                }
            }
            allow_input = (flash_timer == 0) &amp;&amp; (slide_timer == 0) &amp;&amp; (delay_timer == 0);
            /*
            Some options require irregular GUI items or backing code
            This is where these options are coded
            */
            if(state == 8 || state == 9)
            {
                // the key mapping code is getting too big: it's a script now
                // on top of that it even became an event, so that it could be overloaded by platform
                event_user(7);
            }
            else
            if(state == 11)
            {
                // This is the character select screen that activates at the start of the level select
                // it presents the available characters using a different layout, so different code
                // will be used to manage this screen
                // cursor: 7 - back, 8 - tails, 9 - sonic, 10 - knuckles
                allow_input = (flash_timer == 0) &amp;&amp; (slide_timer == 0) &amp;&amp; (delay_timer == 0);
                if(allow_input)
                {
                    if input_check_pressed(cUP) || input_check_pressed(cDOWN) {
                        if(cursor == 5)
                        {
                            cursor = 9;
                        }
                        else
                        {
                            cursor = 5;
                        }
                        audio_play_sound(sndBeep,10,false);
                    }
                    if input_check_pressed(cLEFT) {
                        if(cursor != 5)
                        {
                            cursor--;
                            if(cursor == 7)
                            {
                                cursor = 10;
                            }
                        }
                        audio_play_sound(sndBeep,10,false);
                    }
                    if input_check_pressed(cRIGHT) {
                        if(cursor != 5)
                        {
                            cursor++;
                            if(cursor == 11)
                            {
                                cursor = 8;
                            }
                        }
                        audio_play_sound(sndBeep,10,false);
                    }
                    // activating the seleted item
                    if input_check_pressed(cACTION) || input_check_pressed(cSTART) {
                        event_user(5);
                    }
                    
                    // if we want to cancel, the "back" menu item is found and activated
                    if input_check_pressed(cCANCEL) {
                        active = false;
                    }
                }
            }
        }
    }
    flash_on = !flash_on;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
