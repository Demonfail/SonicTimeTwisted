<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>active = false;

state = 0;
default_state = 2;

cursor = 0;
max_cursor = 0;

options = false;
options_initialized = false;

// if true, the title is displayed for a couple of seconds before the menu proper
// example: special stages
delay_timer = 0;
delay_timer_default = 60;

// flash timer - flashing when an option is selected before executing it
flash_timer = 0;

// slide timer - slide from one option screen to another
slide_timer = 0;
slide_dir = false; // false = left, true = right
slide_to_state = 0;
slide_to_cursor = 0;
slide_from_state = 0;
slide_x_shift = 0;

// for options that must be constantly flashing (yes, those sometimes exist)
// this flag is used to determine whether they should be drawn 
flash_on = false;

// the menu is supposed to be centered - calculate the Y offset needed to do so
menu_y_offset = 0;


// if true, add view offsets to the draw coordinates
draw_with_view_offset = true;

// 
large = false;

back_state = 0;
back_cursor = 0;
use_default_interface = true;

allow_input = true;
wait_for_release = false;

// this variable might be useful in particular cases, such as remapping keys
substate = 0; 
// this will be very useful for key mappings
temp_map = ds_map_create();
// axis - well, looks like this is necessary for being able to detect axis mappings
axis = "";
wait_for_release_axis = false;
// in case we want a confirmation screen ; these variables will store the state
// and cursor which demanded to display it
confirm_state = 0;
confirm_cursor = 0;
confirm_animation = 0;
confirm_text = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_map_destroy(temp_map);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="15">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// processing a click or a confirm key press - code reusable inside of this object
if(!(cursor == 0 &amp;&amp; options[0, OPTION_TYPE] == OPTION_TYPE_TITLE))
{
    if(options[cursor, OPTION_TYPE] == OPTION_TYPE_SUBMENU)
    {
        audio_play_sound(sndBeep,10,false);
        slide_dir = true;
        slide_timer = 30;
        slide_to_state = real(options[cursor, OPTION_VALUE]);
        slide_to_cursor = 0;
        slide_from_state = state;
    }
    else
    if(options[cursor, OPTION_TYPE] == OPTION_TYPE_RETURN)
    {
        audio_play_sound(sndBeep,10,false);
        slide_dir = false;
        slide_timer = 30;
        if(state != 10)
        {
            slide_to_state = real(options[cursor, OPTION_VALUE]);
            slide_to_cursor = 0;
            slide_from_state = state;
        }
        else
        {
            slide_to_state = confirm_state;
            slide_to_cursor = confirm_cursor;
            slide_from_state = 10;
        }
    }
    else
    if(options[cursor, OPTION_TYPE] == OPTION_TYPE_CONFIRM)
    {
        audio_play_sound(sndBeep,10,false);
        slide_dir = true;
        slide_timer = 30;
        slide_to_state = 10;
        slide_to_cursor = 0;
        slide_from_state = state;
        
        confirm_state = state;
        confirm_cursor = cursor;
        confirm_animation = options[cursor, OPTION_ANIMATION];
        confirm_text = options[cursor, OPTION_VALUE];
    }
    else
    {
        if(options[cursor, OPTION_ANIMATION] == OPTION_ANIMATION_LONGPRESS)
        {
            audio_play_sound(sndLampPost,10,false);
            flash_timer = 30;
        }
        else
        {
            audio_play_sound(sndBeep,10,false);
            event_user(2);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw - called by parent object
if(active)
{
    var x_offset = slide_x_shift;
    var y_offset = menu_y_offset;
    if(draw_with_view_offset)
    {
        x_offset += view_xview[view_current];
        y_offset += view_yview[view_current];
    }

    
    draw_set_color(c_yellow);
    
    for(var i = 0; i &lt; array_height_2d(options); i++)
    {
        var line_visible = true;
        if(delay_timer &gt; 0)
        {
            if(options[i, OPTION_TYPE] != OPTION_TYPE_TITLE)
            {
                line_visible = false;
            }
        }
        else
        {
            if(cursor == i)
            {
                if(large)
                {
                    draw_sprite_ext(sprSelectLong,image_index,x_offset+213, y_offset+20*i+6,1,1,0,c_white,1);
                }
                else
                {
                    draw_sprite_ext(sprLevelSelect,image_index,x_offset+213, y_offset+20*i+6,1,1,0,c_white,1);
                }
                
                if(flash_timer &gt; 0)
                {
                    line_visible = (flash_timer mod 2) == 0;
                }
            }
        }
        if(line_visible &amp;&amp; (options[i, OPTION_ANIMATION] != OPTION_ANIMATION_FLASHING || flash_on))
        {
            if(options[i, OPTION_TYPE] == OPTION_TYPE_WITH_VALUE)
            {
                if(large)
                {
                    draw_set_halign(fa_left);
                    draw_text_color(x_offset+213 - 170, y_offset+20*i, options[i, OPTION_NAME],c_white,c_white,c_yellow,c_yellow,1);
                    draw_set_halign(fa_right);
                    draw_text_color(x_offset+213 + 170, y_offset+20*i, options[i, OPTION_VALUE],c_white,c_white,c_yellow,c_yellow,1);
                }
                else
                {
                    draw_set_halign(fa_left);
                    draw_text_color(x_offset+213 - 100, y_offset+20*i, options[i, OPTION_NAME],c_white,c_white,c_yellow,c_yellow,1);
                    draw_set_halign(fa_right);
                    draw_text_color(x_offset+213 + 100, y_offset+20*i, options[i, OPTION_VALUE],c_white,c_white,c_yellow,c_yellow,1);
                }
            }
            else
            {
                draw_set_halign(fa_center);
                draw_text_color(x_offset+213, y_offset+20*i, options[i, OPTION_NAME],c_white,c_white,c_yellow,c_yellow,1);
            }

        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// what to do when "back" is pushed - called by parent object
if(active)
{

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Execute actions when option is selected - called by this object

var usedState = state;
var usedCursor = cursor;
// if we're currently confirming a selection: use the action asociated with the
// object that asked for confirmation, not the one associated with the
// "confirm" option
if(state == 10 &amp;&amp; cursor == 1)
{
    usedState = confirm_state;
    usedCursor = confirm_cursor;
}

if(active)
{
    switch(usedState)
    {
        case 1:
            // Title screen
            switch(usedCursor)
            {
                case 0: // Play
                    transition_to(objFadeWhite, saveSelect, 10);
                break;
                case 2: // Quit
                    game_end();
                break;
            }
            break;
        case 2:
            // Game pause menu
            switch(usedCursor)
            {
                case 0: // Resume
                    objProgram.paused = false;
                    game_pause(objProgram.paused);
                    active = false;
                break;
                case 2: // Restart
                     game_restart();
                break;
            }
            break;
        case 3:
            // Game pause menu - special stage
            switch(usedCursor)
            {
                case 0: // Resume
                    objProgram.paused = false;
                    game_pause(objProgram.paused);
                    active = false;
                break;
                case 2: // Restart
                     game_restart();
                break;
            }
            break;
        case 4:
        case 5:
        case 6:
            // Special stage failure menu
            switch(usedCursor)
            {
                case 1: // Return to act if no lives left; restart if lives left
                    if(objGameData.player_lives[0] &gt; 1)
                    {
                        objGameData.player_lives[0] -= 1;
                        save_lives(objGameData.player_lives[0]);
                        room_restart();
                        with objSSLevel loopMusic = true;
                    }
                    else
                    {
                        with(objSSHud)
                        {
                            closeMenu = true;
                        }
                        active = false;
                        stop_all_music(false);
                        level_goback();
                    }
                break;
                case 2: // Return to act
                    with(objSSHud)
                    {
                        closeMenu = true;
                    }
                    active = false;
                    stop_all_music(false);
                    level_goback();
                break;
            }
            break;
        case 7:
            // Options menu
            switch(usedCursor)
            {
                case 1: // screen size
                    with objScreen {
                        if window_state &lt; 4 {
                            window_state += 1;
                            window_scale = window_state
                            if window_state == 4 {
                                window_scale = 3;
                            }
                            window_set_size(width * window_scale, height * window_scale);
                            alarm[0]=1;
                            if window_state == 4 {
                                window_set_fullscreen(true);        
                            }
                        }
                        else
                        {
                            window_state = 1;
                            window_scale = 1;
                            
                            window_set_fullscreen(false);
                            window_set_size(width * window_scale, height * window_scale);
                            alarm[0]=1;
                        }
                    }
                    event_user(1);
                    break;
                case 2: // gamepad enabled/disabled
                    with(objInput)
                    {
                        event_user(0);
                    }
                    event_user(1);
                    break;
            }
            
            break;
        case 8:
        case 9:
            switch(usedCursor)
            {
                // key mapping screen
                case 1:
                    // Remap all
                    substate = 2;
                    break;
                case 2:
                    // Remap up
                case 3:
                    // Remap down
                case 4:
                    // Remap left
                case 5:
                    // Remap right
                case 6:
                    // Remap A
                case 7:
                    // Remap B
                case 8:
                    // Remap C
                case 9:
                    // Remap start
                    substate = usedCursor;
                    break;
            }
            use_default_interface = false;
            event_user(1);
            break;
        default:
            //show_message(string(state)+" - "+string(cursor));
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init available options for every state - called by this object

options = false;
//use_default_interface = true;
large = false;
if(state == 0)
{
   state = default_state;
}
switch(state)
{
    case 1:
        options[0, OPTION_NAME] = 'PLAY';
        options[0, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[1, OPTION_NAME] = 'OPTIONS';
        options[1, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[1, OPTION_VALUE] = 7;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[2, OPTION_NAME] = 'EXIT GAME';
        options[2, OPTION_TYPE] = OPTION_TYPE_CONFIRM;
        options[2, OPTION_VALUE] = false;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        break;
    case 2:
    case 3:
        options[0, OPTION_NAME] = 'CONTINUE';
        options[0, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[1, OPTION_NAME] = 'OPTIONS';
        options[1, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[1, OPTION_VALUE] = 7;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[2, OPTION_NAME] = 'RESTART GAME';
        options[2, OPTION_TYPE] = OPTION_TYPE_CONFIRM;
        options[2, OPTION_VALUE] = "ALL UNSAVED PROGRESS WILL BE LOST";
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        break;
    case 4:
    case 5:
    case 6:
        var title = "";
        
        switch(state)
        {
            case 4:
                title = 'OUT OF RINGS';
                break;
            case 5:
                title = 'OFF TRACK';
                break;
            case 6:
                title = 'METAL SONIC WINS';
                break;
        }
        options[0, OPTION_NAME] = title;
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        if(objGameData.player_lives[0] &gt; 1)
        {
            options[1, OPTION_NAME] = 'TRY AGAIN z1 LIFE';
            options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
            options[1, OPTION_VALUE] = false;
            options[1, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
            options[2, OPTION_NAME] = 'RETURN TO ACT';
            options[2, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
            options[2, OPTION_VALUE] = false;
            options[2, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        }
        else
        {
            options[1, OPTION_NAME] = 'RETURN TO ACT';
            options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
            options[1, OPTION_VALUE] = false;
            options[1, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        }
        break;
    case 7:
        large = true;
        var screenStateLabel = "FULLSCREEN";
        switch objScreen.window_state {
            case 1:
                screenStateLabel = "WINDOW";
            break;
            case 2:
                screenStateLabel = "WINDOW 2X";
            break;
            case 3:
                screenStateLabel = "WINDOW 3X";
            break;
        }
        
        var gamepadStateLabel = "DISABLED";
        if(objInput.gamepad_update_enabled)
        {
            gamepadStateLabel = "ENABLED";
        }
    
        options[0, OPTION_NAME] = 'OPTIONS';
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = '';
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[1, OPTION_NAME] = 'SCREEN SIZE';
        options[1, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[1, OPTION_VALUE] = screenStateLabel;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[2, OPTION_NAME] = 'ENABLE GAMEPAD F1';
        options[2, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[2, OPTION_VALUE] = gamepadStateLabel;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[3, OPTION_NAME] = 'MAP KEYS';
        options[3, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[3, OPTION_VALUE] = 8;
        options[3, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[4, OPTION_NAME] = 'MAP GAMEPAD';
        options[4, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[4, OPTION_VALUE] = 9;
        options[4, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[5, OPTION_NAME] = 'BACK';
        options[5, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[5, OPTION_VALUE] = 0;
        options[5, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        break;
    case 8:
    case 9:
        var upLabel = 0;
        var downLabel = 0;
        var leftLabel = 0;
        var rightLabel = 0;
        var aLabel = 0;
        var bLabel = 0;
        var cLabel = 0;
        var startLabel = 0;
        if(state == 8)
        {
            for(var i=0; i &lt; objInput.key_count; i++)
            {
                var stored_key;
                if(ds_map_exists(temp_map, objInput.key_control[i]))
                {
                    stored_key = ds_map_find_value(temp_map, objInput.key_control[i]);
                }
                else
                {
                    stored_key = objInput.key[i];
                }
                switch(objInput.key_control[i])
                {
                    case cUP:
                        upLabel = get_kb_label(stored_key);
                        break;
                    case cDOWN:
                        downLabel = get_kb_label(stored_key);
                        break;
                    case cLEFT:
                        leftLabel = get_kb_label(stored_key);
                        break;
                    case cRIGHT:
                        rightLabel = get_kb_label(stored_key);
                        break;
                    case cA:
                        aLabel = get_kb_label(stored_key);
                        break;
                    case cB:
                        bLabel = get_kb_label(stored_key);
                        break;
                    case cC:
                        cLabel = get_kb_label(stored_key);
                        break;
                    case cSTART:
                        startLabel = get_kb_label(stored_key);
                        break;
                }
            }
        }
        else
        {
            for(var i=0; i &lt; objInput.button_count; i++)
            {
                var stored_key;
                if(ds_map_exists(temp_map, objInput.button_control[i]))
                {
                    stored_key = ds_map_find_value(temp_map, objInput.button_control[i]);
                }
                else
                {
                    stored_key = objInput.button[i];
                }
                switch(objInput.button_control[i])
                {
                    case cUP:
                        upLabel = get_gp_label(stored_key);
                        break;
                    case cDOWN:
                        downLabel = get_gp_label(stored_key);
                        break;
                    case cLEFT:
                        leftLabel = get_gp_label(stored_key);
                        break;
                    case cRIGHT:
                        rightLabel = get_gp_label(stored_key);
                        break;
                    case cA:
                        aLabel = get_gp_label(stored_key);
                        break;
                    case cB:
                        bLabel = get_gp_label(stored_key);
                        break;
                    case cC:
                        cLabel = get_gp_label(stored_key);
                        break;
                    case cSTART:
                        startLabel = get_gp_label(stored_key);
                        break;
                }
            }
            for(var i=0; i &lt; objInput.axis_count; i++)
            {
                var stored_key;
                if(ds_map_exists(temp_map, objInput.axis_control[i]))
                {
                    stored_key = ds_map_find_value(temp_map, objInput.axis_control[i]);
                }
                else
                {                
                    var axiscode = "+";
                    if(objInput.axis_direction[i] &lt; 0)
                    {
                        axiscode = "-";
                    }
                    axiscode += string(objInput.axis[i]);
                    stored_key = axiscode;
                }
                
                switch(objInput.axis_control[i])
                {
                    case cUP:
                        upLabel = get_gp_label(stored_key);
                        break;
                    case cDOWN:
                        downLabel = get_gp_label(stored_key);
                        break;
                    case cLEFT:
                        leftLabel = get_gp_label(stored_key);
                        break;
                    case cRIGHT:
                        rightLabel = get_gp_label(stored_key);
                        break;
                    case cA:
                        aLabel = get_gp_label(stored_key);
                        break;
                    case cB:
                        bLabel = get_gp_label(stored_key);
                        break;
                    case cC:
                        cLabel = get_gp_label(stored_key);
                        break;
                    case cSTART:
                        startLabel = get_gp_label(stored_key);
                        break;
                }
            }
        }
        
        var pressCancelMessage = "PRESS "+objProgram.back_button_label+" TO CANCEL";
        
        options[0, OPTION_NAME] = 'MAP KEYS';
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        if(state == 9)
        {
            options[0, OPTION_NAME] = 'MAP GAMEPAD';
        }
        
        options[1, OPTION_NAME] = 'REMAP ALL';
        options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[1, OPTION_VALUE] = false;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[2, OPTION_NAME] = 'UP';
        options[2, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[2, OPTION_VALUE] = upLabel;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[3, OPTION_NAME] = 'DOWN';
        options[3, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[3, OPTION_VALUE] = downLabel;
        options[3, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[4, OPTION_NAME] = 'LEFT';
        options[4, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[4, OPTION_VALUE] = leftLabel;
        options[4, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[5, OPTION_NAME] = 'RIGHT';
        options[5, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[5, OPTION_VALUE] = rightLabel;
        options[5, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[6, OPTION_NAME] = 'A';
        options[6, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[6, OPTION_VALUE] = aLabel;
        options[6, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[7, OPTION_NAME] = 'B';
        options[7, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[7, OPTION_VALUE] = bLabel;
        options[7, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[8, OPTION_NAME] = 'C';
        options[8, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[8, OPTION_VALUE] = cLabel;
        options[8, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[9, OPTION_NAME] = 'START';
        options[9, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[9, OPTION_VALUE] = startLabel;
        options[9, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        if(!use_default_interface)
        {
            if(substate &gt;= 2 &amp;&amp; substate &lt;= 10)
            {
                options[cursor, OPTION_NAME] = pressCancelMessage;
                options[substate, OPTION_ANIMATION] = OPTION_ANIMATION_FLASHING;
            }
        }
        
        options[10, OPTION_NAME] = 'BACK';
        options[10, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[10, OPTION_VALUE] = 7;
        options[10, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        break;
    case 10:
        options[0, OPTION_NAME] = confirm_text;
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[1, OPTION_NAME] = 'CONFIRM';
        options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[1, OPTION_VALUE] = false;
        options[1, OPTION_ANIMATION] = confirm_animation;
        
        options[2, OPTION_NAME] = 'CANCEL';
        options[2, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[2, OPTION_VALUE] = confirm_state;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        break;
    default:
        options[0, OPTION_NAME] = 'STATE DOES NOT EXIST';
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        break;
        
}
// calculating the Y offset
max_cursor = array_height_2d(options) - 1;
menu_y_offset = floor((view_hview[view_current] - 20 * array_height_2d(options))/2);

options_initialized = true;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// step - called by parent object

/*
States available by default (ports to other platforms will extend this list):

0 - default state - see below
1 - main title screen
2 - level pause menu
3 - special stage pause menu
4 - special stage retry menu (out of rings)
5 - special stage retry menu (lost)
6 - special stage retry menu (off track)
7 - options
8 - control config - keyboard
9 - control config - gamepad
10 - confirmation screen

*/
if(active)
{
    // there is no such thing as default state - a default state must be a context-specific one
    if(state == 0)
    {
       state = default_state;
    }
    
    if(!options_initialized)
    {
        event_user(1);
    }
    if(wait_for_release)
    {
        if (input_check_released(cSTART))
        {
            wait_for_release = false;
        }
    }
    else
    {
        if(use_default_interface)
        {
            /*
            Here, this is the code responsible for how the menu
            regularly operates
            
            */
            if(cursor == 0)
            {
                // if it's a menu title, it's not supposed to be selectable
                if (options[0, OPTION_TYPE] == OPTION_TYPE_TITLE)
                {
                    cursor = 1;
                }
            }
            // Input is only allowed if no animation is playing
            allow_input = (flash_timer == 0) &amp;&amp; (slide_timer == 0) &amp;&amp; (delay_timer == 0);
            if(allow_input)
            {
                // moving up, looping if necessary, skipping the title if there's one
                if input_check_pressed(cUP) {
                    audio_play_sound(sndBeep,10,false);
                    cursor--;
                    if(cursor == 0)
                    {
                        if(options[0, OPTION_TYPE] == OPTION_TYPE_TITLE)
                        {
                            cursor = max_cursor;
                        }
                    }
                    if(cursor &lt; 0)
                    {
                        cursor = max_cursor;
                    }
                }
                
                // moving down, looping if necessary, skipping the title if there's one
                if input_check_pressed(cDOWN) {
                    audio_play_sound(sndBeep,10,false);
                    cursor++;
                    if(cursor &gt; max_cursor)
                    {
                        cursor = 0;
                        if(options[0, OPTION_TYPE] == OPTION_TYPE_TITLE)
                        {
                            cursor = 1;
                        }
                    }
                }
                
                // activating the seleted item
                if input_check_pressed(cACTION) || input_check_pressed(cSTART) {
                    event_user(5);
                }
                
                // if we want to cancel, the "back" menu item is found and activated
                if input_check_pressed(cCANCEL) {
                    for(var i = 0; i &lt; max_cursor; i++)
                    {
                        if(options[i, OPTION_TYPE] == OPTION_TYPE_RETURN)
                        {
                            cursor = i;
                            event_user(5);
                            break;
                        }
                    }
                }
            }
            else
            {
                if(flash_timer &gt; 0)
                {
                    // some items play a flashing animation before activating
                    flash_timer--;
                    if(flash_timer == 0)
                    {
                        event_user(2);
                    }
                }
                else
                if(slide_timer &gt; 0)
                {
                    // this is the animation that plays when sliding between option screens
                    slide_timer--;
                    if(slide_timer == 15)
                    {
                        state = slide_to_state;
                        cursor = slide_to_cursor;
                        event_user(1);
                        for(var i = 0; i &lt; max_cursor; i++)
                        {
                            if(options[i, OPTION_TYPE] == OPTION_TYPE_SUBMENU)
                            {
                                if(options[i, OPTION_VALUE] == slide_from_state)
                                {
                                    cursor = i;
                                }
                            }
                        }
                    }
                    var diffxperframe = view_wview[view_current] / 15;
                    if(slide_timer &gt; 15)
                    {
                        slide_x_shift = -1 * diffxperframe * (30 - slide_timer);
                    }
                    else
                    {
                        slide_x_shift = diffxperframe * slide_timer;
                    }
                    if(!slide_dir)
                    {
                        slide_x_shift *= -1;
                    }
                }
                else
                if(delay_timer &gt; 0)
                {
                    // this is just for the special stage failure menus where a title must be shown for a bit before the rest
                    delay_timer--;
                }
            }
        }
        else
        {
            /*
            Some options require irregular GUI items or backing code
            This is where these options are coded
            */
            if(state == 8 || state == 9)
            {
                /*
                currently remapping keys on the keyboard (state 8)
                or buttons/axes on a gamepad (state 9)
                
                substate is basically:
                2 - remapping up
                3 - remapping down
                4 - remapping left
                5 - remapping right
                6 - remapping A
                7 - remapping B
                8 - remapping C
                9 - remapping START
                10 - dumping everything we've remapped so far to the configuration file
                
                if cursor is equal to substate, we are only remapping one button
                if cursor is 1, we're remapping everything
                pressing ESC (or a similar key on a different platform) cancels everything
                */
                if(substate &gt;= 2 &amp;&amp; substate &lt;= 9)
                {
                    var keyToMap = 0;
                    switch(substate)
                    {
                        case 2:
                             keyToMap = cUP;
                             break;
                        case 3:
                             keyToMap = cDOWN;
                             break;
                        case 4:
                             keyToMap = cLEFT;
                             break;
                        case 5:
                             keyToMap = cRIGHT;
                             break;
                        case 6:
                             keyToMap = cA;
                             break;
                        case 7:
                             keyToMap = cB;
                             break;
                        case 8:
                             keyToMap = cC;
                             break;
                        case 9:
                             keyToMap = cSTART;
                             break;
                    }
                    if(state == 8)
                    {
                        if keyboard_check_pressed(vk_anykey) {
                            if (keyboard_lastkey == objProgram.back_button)
                            {
                                // cancel key pressed - Abort! Abort! Abort! Return to the menu's usual operating mode
                                ds_map_destroy(temp_map);
                                temp_map = ds_map_create();
                                use_default_interface = true;
                                substate = 0;
                            }
                            else
                            {
                                var key = 0;
                                if(keyToMap &gt; 0)
                                {
                                    ds_map_add(temp_map, keyToMap, keyboard_lastkey);
                                }
                                if(substate == cursor)
                                {
                                    substate = 10;
                                }
                                else
                                {
                                    substate++;
                                }
                            }
                            event_user(1);
                        }
                    }
                    else
                    if(state == 9)
                    {
                        // remapping up on gamepad
                        if(keyboard_check_pressed(objProgram.back_button))
                        {
                            // cancel key pressed - Abort! Abort! Abort! Return to the menu's usual operating mode
                            // it's also present in this option, in case the player wants to remap the peripheral they don't have
                            // would hate to softlock the game, is all :)
                            ds_map_destroy(temp_map);
                            temp_map = ds_map_create();
                            use_default_interface = true;
                            substate = 0;
                            event_user(1);
                        }
                        else
                        {
                            var mapped = false;
                            var padButton = input_any_gamepad_button()
                            if padButton { 
                                ds_map_add(temp_map, keyToMap, padButton);
                                mapped = true;
                            }
                            if(wait_for_release_axis)
                            {
                                axis = input_any_gamepad_axis();
                                if(axis == "")
                                {
                                    wait_for_release_axis = false;
                                }
                            }
                            else
                            {
                                if(axis == "")
                                {
                                    axis = input_any_gamepad_axis();
                                }
                                if axis != "" {
                                    if input_any_gamepad_axis() == "" {
                                        // axes can only be mapped to directions
                                        if(keyToMap == cUP || keyToMap == cDOWN || keyToMap == cLEFT || keyToMap == cRIGHT)
                                        {
                                            ds_map_add(temp_map, keyToMap, axis);
                                            mapped = true;
                                        }
                                        wait_for_release_axis = true;
                                    }
                                }
                            }
                            if(mapped)
                            {
                                if(substate == cursor)
                                {
                                    substate = 10;
                                }
                                else
                                {
                                    substate++;
                                }
                                event_user(1);
                            }
                        }
                    }  
                }        
                else
                if(substate == 10)
                {
                    // and this is where everything is dumped to the configuration file and applied in-game
                    var size, key, i;
                    size = ds_map_size(temp_map);
                    key = ds_map_find_first(temp_map);
                    for (i = 0; i &lt; size; i++;)
                    {
                        if(key == cUP || key == cDOWN || key == cLEFT || key == cRIGHT || key == cA || key == cB || key == cC || key == cSTART)
                        {
                            var iniKey = "";
                            switch(key)
                            {
                                case cUP:
                                    iniKey = "up";
                                    break;
                                case cDOWN:
                                    iniKey = "down";
                                    break;
                                case cLEFT:
                                    iniKey = "left";
                                    break;
                                case cRIGHT:
                                    iniKey = "right";
                                    break;
                                case cA:
                                    iniKey = "a";
                                    break;
                                case cB:
                                    iniKey = "b";
                                    break;
                                case cC:
                                    iniKey = "c";
                                    break;
                                case cSTART:
                                    iniKey = "start";
                                    break;
                            }
                            if(iniKey != "")
                            {
                                if(state == 8)
                                {
                                    // save key for keyboard
                                   save_control_map_keyboard(iniKey,ds_map_find_value(temp_map, key));
                                }
                                else
                                if(state == 9)
                                {
                                    // save for gamepad
                                   save_control_map_gamepad(iniKey,ds_map_find_value(temp_map, key));
                                }
                            }
                        }
                        key = ds_map_find_next(temp_map, key);
                    }
                    // everything's dumped? good! Let's now apply it and go back to the menu's regular operations
                    with objInput input_load();
                    wait_for_release = true;
                    ds_map_destroy(temp_map);
                    temp_map = ds_map_create();
                    use_default_interface = true;
                    substate = 0;
                    event_user(1);
                }
                else
                {
                    wait_for_release = true;
                    substate = 0;
                    ds_map_destroy(temp_map);
                    temp_map = ds_map_create();
                    use_default_interface = true;
                    event_user(1);
                }
            }
        }
    }
    flash_on = !flash_on;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
