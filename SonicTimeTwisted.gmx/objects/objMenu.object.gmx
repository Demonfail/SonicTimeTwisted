<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// States
/*
States available by default (ports to other platforms will extend this list):

0 - default state - see below
1 - main title screen
2 - level pause menu
3 - special stage pause menu
4 - special stage retry menu (out of rings)
5 - special stage retry menu (lost)
6 - special stage retry menu (off track)
7 - options
8 - control config - keyboard
9 - control config - gamepad
10 - confirmation screen
11 - level select - character select
12 - level select - zone select
13 - level select - attraction attack
14 - level select - raging ruins
15 - level select - frigid fortress
16 - level select - viridian valley
17 - level select - drifting dynamo
18 - level select - tidal tubes
19 - level select - planetary panic

*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>active = false;

state = 0;
default_state = 2;

cursor = 0;
max_cursor = 0;

options = false;
options_initialized = false;

// if true, the title is displayed for a couple of seconds before the menu proper
// example: special stages
delay_timer = 0;
delay_timer_default = 60;

// flash timer - flashing when an option is selected before executing it
flash_timer = 0;

// slide timer - slide from one option screen to another
slide_timer = 0;
slide_dir = false; // false = left, true = right
slide_to_state = 0;
slide_to_cursor = 0;
slide_from_state = 0;
slide_x_shift = 0;

// for options that must be constantly flashing (yes, those sometimes exist)
// this flag is used to determine whether they should be drawn 
flash_on = false;

// the menu is supposed to be centered - calculate the Y offset needed to do so
menu_y_offset = 0;


// if true, add view offsets to the draw coordinates
draw_with_view_offset = true;

// 
large = false;

back_state = 0;
back_cursor = 0;
use_default_interface = true;

allow_input = true;
wait_for_release = false;

// this variable might be useful in particular cases, such as remapping keys
substate = 0; 
// this will be very useful for key mappings
temp_map = ds_map_create();
// axis - well, looks like this is necessary for being able to detect axis mappings
axis = "";
wait_for_release_axis = false;
// in case we want a confirmation screen ; these variables will store the state
// and cursor which demanded to display it
confirm_state = 0;
confirm_cursor = 0;
confirm_animation = 0;
confirm_text = 0;
// draw offset variables - could have been "var", but inheriting objects might want to use those
x_offset = 0;
y_offset = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_map_destroy(temp_map);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="16">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// special draw for some states - overrideable
if(state == 11)
{
    // draw character select sprites
    if(cursor == 8)
    {
        draw_sprite(sprCharacterSelect, 1, x_offset+96, view_yview[view_current] + 112);
        draw_sprite(sprSelector, 1, x_offset+96, view_yview[view_current] + 112);
    }
    else
    {
        draw_sprite_ext(sprCharacterSelect, 1, x_offset+96, view_yview[view_current] + 112, 1, 1, 0, c_white, 0.5);
    }
    if(cursor == 9)
    {
        draw_sprite(sprCharacterSelect, 0, x_offset+216, view_yview[view_current] + 112);
        draw_sprite(sprSelector, 0, x_offset+216, view_yview[view_current] + 112);
    }
    else
    {
        draw_sprite_ext(sprCharacterSelect, 0, x_offset+216, view_yview[view_current] + 112, 1, 1, 0, c_white, 0.5);
    }
    if(cursor == 10)
    {
        draw_sprite(sprCharacterSelect, 2, x_offset+336, view_yview[view_current] + 112);
        draw_sprite(sprSelector, 2, x_offset+336, view_yview[view_current] + 112);
    }
    else
    {
        draw_sprite_ext(sprCharacterSelect, 2, x_offset+336, view_yview[view_current] + 112, 1, 1, 0, c_white, 0.5);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="15">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// processing a click or a confirm key press - code reusable inside of this object
if(cursor &lt; array_height_2d(options) &amp;&amp; !(cursor == 0 &amp;&amp; options[0, OPTION_TYPE] == OPTION_TYPE_TITLE))
{
    if(options[cursor, OPTION_TYPE] == OPTION_TYPE_SUBMENU)
    {
        audio_play_sound(sndBeep,10,false);
        slide_dir = true;
        slide_timer = 30;
        slide_to_state = real(options[cursor, OPTION_VALUE]);
        slide_to_cursor = 0;
        slide_from_state = state;
    }
    else
    if(options[cursor, OPTION_TYPE] == OPTION_TYPE_RETURN)
    {
        audio_play_sound(sndBeep,10,false);
        slide_dir = false;
        slide_timer = 30;
        if(state != 10)
        {
            slide_to_state = real(options[cursor, OPTION_VALUE]);
            slide_to_cursor = 0;
            slide_from_state = state;
        }
        else
        {
            slide_to_state = confirm_state;
            slide_to_cursor = confirm_cursor;
            slide_from_state = 10;
        }
    }
    else
    if(options[cursor, OPTION_TYPE] == OPTION_TYPE_CONFIRM)
    {
        audio_play_sound(sndBeep,10,false);
        slide_dir = true;
        slide_timer = 30;
        slide_to_state = 10;
        slide_to_cursor = 0;
        slide_from_state = state;
        
        confirm_state = state;
        confirm_cursor = cursor;
        confirm_animation = options[cursor, OPTION_ANIMATION];
        confirm_text = options[cursor, OPTION_VALUE];
    }
    else
    {
        if(options[cursor, OPTION_ANIMATION] == OPTION_ANIMATION_LONGPRESS)
        {
            audio_play_sound(sndLampPost,10,false);
            flash_timer = 30;
        }
        else
        {
            audio_play_sound(sndBeep,10,false);
            event_user(2);
        }
    }
}
else
{
    audio_play_sound(sndBeep,10,false);
    event_user(2);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw - called by parent object
if(active)
{
    x_offset = slide_x_shift;
    y_offset = menu_y_offset;
    if(draw_with_view_offset)
    {
        x_offset += view_xview[view_current];
        y_offset += view_yview[view_current];
    }

    
    draw_set_color(c_yellow);
    
    for(var i = 0; i &lt; array_height_2d(options); i++)
    {
        var line_visible = true;
        if(delay_timer &gt; 0)
        {
            if(options[i, OPTION_TYPE] != OPTION_TYPE_TITLE)
            {
                line_visible = false;
            }
        }
        else
        {
            if(cursor == i)
            {
                if(large)
                {
                    draw_sprite_ext(sprSelectLong,image_index,x_offset+213, y_offset+20*i+6,1,1,0,c_white,1);
                }
                else
                {
                    draw_sprite_ext(sprLevelSelect,image_index,x_offset+213, y_offset+20*i+6,1,1,0,c_white,1);
                }
                
                if(flash_timer &gt; 0)
                {
                    line_visible = (flash_timer mod 2) == 0;
                }
            }
        }
        if(line_visible &amp;&amp; (options[i, OPTION_ANIMATION] != OPTION_ANIMATION_FLASHING || flash_on))
        {
            if(options[i, OPTION_TYPE] == OPTION_TYPE_WITH_VALUE)
            {
                if(large)
                {
                    draw_set_halign(fa_left);
                    draw_text_color(x_offset+213 - 170, y_offset+20*i, options[i, OPTION_NAME],c_white,c_white,c_yellow,c_yellow,1);
                    draw_set_halign(fa_right);
                    draw_text_color(x_offset+213 + 170, y_offset+20*i, options[i, OPTION_VALUE],c_white,c_white,c_yellow,c_yellow,1);
                }
                else
                {
                    draw_set_halign(fa_left);
                    draw_text_color(x_offset+213 - 100, y_offset+20*i, options[i, OPTION_NAME],c_white,c_white,c_yellow,c_yellow,1);
                    draw_set_halign(fa_right);
                    draw_text_color(x_offset+213 + 100, y_offset+20*i, options[i, OPTION_VALUE],c_white,c_white,c_yellow,c_yellow,1);
                }
            }
            else
            {
                draw_set_halign(fa_center);
                draw_text_color(x_offset+213, y_offset+20*i, options[i, OPTION_NAME],c_white,c_white,c_yellow,c_yellow,1);
            }

        }
    }
    if(state == 11)
    {
        // draw character select sprites
        event_user(6);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// what to do when "back" is pushed - called by parent object
if(active)
{

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Execute actions when option is selected - called by this object

var usedState = state;
var usedCursor = cursor;
// if we're currently confirming a selection: use the action asociated with the
// object that asked for confirmation, not the one associated with the
// "confirm" option
if(state == 10 &amp;&amp; cursor == 1)
{
    usedState = confirm_state;
    usedCursor = confirm_cursor;
}

if(active)
{
    switch(usedState)
    {
        case 1:
            // Title screen
            switch(usedCursor)
            {
                case 0: // Play
                    transition_to(objFadeWhite, saveSelect, 10);
                break;
                case 2: // Quit
                    game_end();
                break;
            }
            break;
        case 2:
            // Game pause menu
            switch(usedCursor)
            {
                case 0: // Resume
                    objProgram.paused = false;
                    game_pause(objProgram.paused);
                    active = false;
                break;
                case 2: // Restart
                     game_restart();
                break;
            }
            break;
        case 3:
            // Game pause menu - special stage
            switch(usedCursor)
            {
                case 0: // Resume
                    objProgram.paused = false;
                    game_pause(objProgram.paused);
                    active = false;
                break;
                case 2: // Restart
                     game_restart();
                break;
            }
            break;
        case 4:
        case 5:
        case 6:
            // Special stage failure menu
            switch(usedCursor)
            {
                case 1: // Return to act if no lives left; restart if lives left
                    if(objGameData.player_lives[0] &gt; 1)
                    {
                        objGameData.player_lives[0] -= 1;
                        save_lives(objGameData.player_lives[0]);
                        room_restart();
                        with objSSLevel loopMusic = true;
                    }
                    else
                    {
                        with(objSSHud)
                        {
                            closeMenu = true;
                        }
                        active = false;
                        stop_all_music(false);
                        level_goback();
                    }
                break;
                case 2: // Return to act
                    with(objSSHud)
                    {
                        closeMenu = true;
                    }
                    active = false;
                    stop_all_music(false);
                    level_goback();
                break;
            }
            break;
        case 7:
            // Options menu
            switch(usedCursor)
            {
                case 1: // screen size
                    with objScreen {
                        if window_state &lt; 4 {
                            window_state += 1;
                            window_scale = window_state
                            if window_state == 4 {
                                window_scale = 3;
                            }
                            window_set_size(width * window_scale, height * window_scale);
                            alarm[0]=1;
                            if window_state == 4 {
                                window_set_fullscreen(true);        
                            }
                        }
                        else
                        {
                            window_state = 1;
                            window_scale = 1;
                            
                            window_set_fullscreen(false);
                            window_set_size(width * window_scale, height * window_scale);
                            alarm[0]=1;
                        }
                    }
                    event_user(1);
                    break;
                case 2: // score tally mode
                    objProgram.score_tally_mode = (objProgram.score_tally_mode + 1) mod 3;
                    save_options();
                    event_user(1);
                    break;
                case 3: // gamepad enabled/disabled
                    with(objInput)
                    {
                        event_user(0);
                    }
                    event_user(1);
                    break;
            }
            
            break;
        case 8:
        case 9:
            switch(usedCursor)
            {
                // key mapping screen
                case 1:
                    // Remap all
                    substate = 2;
                    break;
                case 2:
                    // Remap up
                case 3:
                    // Remap down
                case 4:
                    // Remap left
                case 5:
                    // Remap right
                case 6:
                    // Remap A
                case 7:
                    // Remap B
                case 8:
                    // Remap C
                case 9:
                    // Remap start
                    substate = usedCursor;
                    break;
            }
            use_default_interface = false;
            event_user(1);
            break;
        case 11:
            use_default_interface = true;
            // level select - character
            switch(usedCursor)
            {
                case 8:
                case 9:
                case 10:
                    switch(usedCursor)
                    {
                        case 8:
                            substate = 2;
                            break;
                        case 9:
                            substate = 1;
                            break;
                        case 10:
                            substate = 3;
                            break;
                    }
                    objGameData.character_id[0] = substate;
                    audio_play_sound(sndBeep,10,false);
                    slide_dir = true;
                    slide_timer = 30;
                    slide_to_state = 12;
                    slide_to_cursor = 1;
                    slide_from_state = state;
                break;
                default:
                    audio_play_sound(sndBeep,10,false);
                    slide_dir = false;
                    slide_timer = 30;
                    slide_to_state = default_state;
                    slide_to_cursor = 0;
                    slide_from_state = state;
            }
            break;
        case 12:
            // Zone select - only two zones are directly selectable here
            switch(usedCursor)
            {
                case 7: // Sunken saucer
                    objProgram.current_level=12;
                    objProgram.in_past = false;
                    level_goto_next()
                    break;
                case 9: // Galacnik Gauntlet
                    objProgram.current_level=15;
                    objProgram.in_past = false;
                    level_goto_next();
                    break;
            }
            break;
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
            // regular stages
            objProgram.in_past = usedCursor mod 2 == 0;
            var curLevel = (usedState - 13) * 2;
            if(usedCursor &gt; 2)
            {
                curLevel++;
            }
            if(curLevel &gt; 0)
            {
                objProgram.current_level=curLevel;
            }
            level_goto_next();
            break;
        case 19:
            objProgram.in_past = false;
            if(usedCursor == 1)
            {
                objProgram.current_level=13;
                level_goto_next()
            }
            else
            {
                objProgram.current_level=14;
                level_goto_next()
            }
            break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init available options for every state - called by this object

options = false;
//use_default_interface = true;
large = false;
if(state == 0)
{
   state = default_state;
}
switch(state)
{
    case 1:
        options[0, OPTION_NAME] = 'PLAY';
        options[0, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[1, OPTION_NAME] = 'OPTIONS';
        options[1, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[1, OPTION_VALUE] = 7;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[2, OPTION_NAME] = 'EXIT GAME';
        options[2, OPTION_TYPE] = OPTION_TYPE_CONFIRM;
        options[2, OPTION_VALUE] = 'EXIT GAME';
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        break;
    case 2:
    case 3:
        options[0, OPTION_NAME] = 'CONTINUE';
        options[0, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[1, OPTION_NAME] = 'OPTIONS';
        options[1, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[1, OPTION_VALUE] = 7;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[2, OPTION_NAME] = 'RESTART GAME';
        options[2, OPTION_TYPE] = OPTION_TYPE_CONFIRM;
        options[2, OPTION_VALUE] = "ALL UNSAVED PROGRESS WILL BE LOST";
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        break;
    case 4:
    case 5:
    case 6:
        var title = "";
        
        switch(state)
        {
            case 4:
                title = 'OUT OF RINGS';
                break;
            case 5:
                title = 'OFF TRACK';
                break;
            case 6:
                title = '';
                break;
        }
        options[0, OPTION_NAME] = title;
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        if(objGameData.player_lives[0] &gt; 1)
        {
            options[1, OPTION_NAME] = 'TRY AGAIN z1 LIFE';
            options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
            options[1, OPTION_VALUE] = false;
            options[1, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
            options[2, OPTION_NAME] = 'RETURN TO ACT';
            options[2, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
            options[2, OPTION_VALUE] = false;
            options[2, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        }
        else
        {
            options[1, OPTION_NAME] = 'RETURN TO ACT';
            options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
            options[1, OPTION_VALUE] = false;
            options[1, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        }
        break;
    case 7:
        large = true;
        var screenStateLabel = "FULLSCREEN";
        switch objScreen.window_state {
            case 1:
                screenStateLabel = "WINDOW";
            break;
            case 2:
                screenStateLabel = "WINDOW 2X";
            break;
            case 3:
                screenStateLabel = "WINDOW 3X";
            break;
        }
        
        var tallyLabel = "RANDOM DIGITS";
        switch(objProgram.score_tally_mode)
        {
            case 1:
                tallyLabel = "VARIABLE SPEED";
                break;
            case 2:
                tallyLabel = "CONSTANT SPEED";
                break;
        }
        
        var gamepadStateLabel = "NO";
        if(objInput.gamepad_update_enabled)
        {
            gamepadStateLabel = "YES";
        }
    
        options[0, OPTION_NAME] = 'OPTIONS';
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = '';
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[1, OPTION_NAME] = 'SCREEN SIZE';
        options[1, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[1, OPTION_VALUE] = screenStateLabel;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[2, OPTION_NAME] = 'SCORE TALLY MODE';
        options[2, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[2, OPTION_VALUE] = tallyLabel;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[3, OPTION_NAME] = 'ENABLE GAMEPAD';
        options[3, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[3, OPTION_VALUE] = gamepadStateLabel;
        options[3, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[4, OPTION_NAME] = 'MAP KEYS';
        options[4, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[4, OPTION_VALUE] = 8;
        options[4, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[5, OPTION_NAME] = 'MAP GAMEPAD';
        options[5, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[5, OPTION_VALUE] = 9;
        options[5, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[6, OPTION_NAME] = 'BACK';
        options[6, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[6, OPTION_VALUE] = 0;
        options[6, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        break;
    case 8:
    case 9:
        var upLabel = 0;
        var downLabel = 0;
        var leftLabel = 0;
        var rightLabel = 0;
        var aLabel = 0;
        var bLabel = 0;
        var cLabel = 0;
        var startLabel = 0;
        if(state == 8)
        {
            for(var i=0; i &lt; objInput.key_count; i++)
            {
                var stored_key;
                if(ds_map_exists(temp_map, objInput.key_control[i]))
                {
                    stored_key = ds_map_find_value(temp_map, objInput.key_control[i]);
                }
                else
                {
                    stored_key = objInput.key[i];
                }
                switch(objInput.key_control[i])
                {
                    case cUP:
                        upLabel = get_kb_label(stored_key);
                        break;
                    case cDOWN:
                        downLabel = get_kb_label(stored_key);
                        break;
                    case cLEFT:
                        leftLabel = get_kb_label(stored_key);
                        break;
                    case cRIGHT:
                        rightLabel = get_kb_label(stored_key);
                        break;
                    case cA:
                        aLabel = get_kb_label(stored_key);
                        break;
                    case cB:
                        bLabel = get_kb_label(stored_key);
                        break;
                    case cC:
                        cLabel = get_kb_label(stored_key);
                        break;
                    case cSTART:
                        startLabel = get_kb_label(stored_key);
                        break;
                }
            }
        }
        else
        {
            for(var i=0; i &lt; objInput.button_count; i++)
            {
                var stored_key;
                if(ds_map_exists(temp_map, objInput.button_control[i]))
                {
                    stored_key = ds_map_find_value(temp_map, objInput.button_control[i]);
                }
                else
                {
                    stored_key = objInput.button[i];
                }
                switch(objInput.button_control[i])
                {
                    case cUP:
                        upLabel = get_gp_label(stored_key);
                        break;
                    case cDOWN:
                        downLabel = get_gp_label(stored_key);
                        break;
                    case cLEFT:
                        leftLabel = get_gp_label(stored_key);
                        break;
                    case cRIGHT:
                        rightLabel = get_gp_label(stored_key);
                        break;
                    case cA:
                        aLabel = get_gp_label(stored_key);
                        break;
                    case cB:
                        bLabel = get_gp_label(stored_key);
                        break;
                    case cC:
                        cLabel = get_gp_label(stored_key);
                        break;
                    case cSTART:
                        startLabel = get_gp_label(stored_key);
                        break;
                }
            }
            for(var i=0; i &lt; objInput.axis_count; i++)
            {
                var stored_key;
                if(ds_map_exists(temp_map, objInput.axis_control[i]))
                {
                    stored_key = ds_map_find_value(temp_map, objInput.axis_control[i]);
                }
                else
                {                
                    var axiscode = "+";
                    if(objInput.axis_direction[i] &lt; 0)
                    {
                        axiscode = "-";
                    }
                    axiscode += string(objInput.axis[i]);
                    stored_key = axiscode;
                }
                
                switch(objInput.axis_control[i])
                {
                    case cUP:
                        upLabel = get_gp_label(stored_key);
                        break;
                    case cDOWN:
                        downLabel = get_gp_label(stored_key);
                        break;
                    case cLEFT:
                        leftLabel = get_gp_label(stored_key);
                        break;
                    case cRIGHT:
                        rightLabel = get_gp_label(stored_key);
                        break;
                    case cA:
                        aLabel = get_gp_label(stored_key);
                        break;
                    case cB:
                        bLabel = get_gp_label(stored_key);
                        break;
                    case cC:
                        cLabel = get_gp_label(stored_key);
                        break;
                    case cSTART:
                        startLabel = get_gp_label(stored_key);
                        break;
                }
            }
        }
        
        var pressCancelMessage = "PRESS "+objProgram.back_button_label+" TO CANCEL";
        
        options[0, OPTION_NAME] = 'MAP KEYS';
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        if(state == 9)
        {
            options[0, OPTION_NAME] = 'MAP GAMEPAD';
        }
        
        options[1, OPTION_NAME] = 'REMAP ALL';
        options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[1, OPTION_VALUE] = false;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[2, OPTION_NAME] = 'UP';
        options[2, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[2, OPTION_VALUE] = upLabel;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[3, OPTION_NAME] = 'DOWN';
        options[3, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[3, OPTION_VALUE] = downLabel;
        options[3, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[4, OPTION_NAME] = 'LEFT';
        options[4, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[4, OPTION_VALUE] = leftLabel;
        options[4, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[5, OPTION_NAME] = 'RIGHT';
        options[5, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[5, OPTION_VALUE] = rightLabel;
        options[5, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[6, OPTION_NAME] = 'A';
        options[6, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[6, OPTION_VALUE] = aLabel;
        options[6, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[7, OPTION_NAME] = 'B';
        options[7, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[7, OPTION_VALUE] = bLabel;
        options[7, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[8, OPTION_NAME] = 'C';
        options[8, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[8, OPTION_VALUE] = cLabel;
        options[8, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[9, OPTION_NAME] = 'START';
        options[9, OPTION_TYPE] = OPTION_TYPE_WITH_VALUE;
        options[9, OPTION_VALUE] = startLabel;
        options[9, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        if(!use_default_interface)
        {
            if(substate &gt;= 2 &amp;&amp; substate &lt;= 10)
            {
                options[cursor, OPTION_NAME] = pressCancelMessage;
                options[substate, OPTION_ANIMATION] = OPTION_ANIMATION_FLASHING;
                options[substate, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
            }
        }
        
        options[10, OPTION_NAME] = 'BACK';
        options[10, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[10, OPTION_VALUE] = 7;
        options[10, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        break;
    case 10:
        options[0, OPTION_NAME] = confirm_text;
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        
        options[1, OPTION_NAME] = 'CONFIRM';
        options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[1, OPTION_VALUE] = false;
        options[1, OPTION_ANIMATION] = confirm_animation;
        
        options[2, OPTION_NAME] = 'CANCEL';
        options[2, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[2, OPTION_VALUE] = confirm_state;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        break;
    case 11:
        // level select - character select : this screen is very different
        substate = 0;
        options[0, OPTION_NAME] = 'CHARACTER SELECT';
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[1, OPTION_NAME] = '';
        options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[1, OPTION_VALUE] = false;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[2, OPTION_NAME] = '';
        options[2, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[2, OPTION_VALUE] = false;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[3, OPTION_NAME] = '';
        options[3, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[3, OPTION_VALUE] = false;
        options[3, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[4, OPTION_NAME] = '';
        options[4, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[4, OPTION_VALUE] = false;
        options[4, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[5, OPTION_NAME] = 'BACK';
        options[5, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[5, OPTION_VALUE] = false;
        options[5, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        cursor = 9;
        use_default_interface = false;
        break;
    case 12:
        // level select - zone select
        use_default_interface = true;
        options[0, OPTION_NAME] = 'ZONE SELECT';
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[1, OPTION_NAME] = 'ATTRACTION ATTACK ZONE';
        options[1, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[1, OPTION_VALUE] = 13;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[2, OPTION_NAME] = 'RAGING RUINS ZONE';
        options[2, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[2, OPTION_VALUE] = 14;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[3, OPTION_NAME] = 'FRIGID FORTRESS ZONE';
        options[3, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[3, OPTION_VALUE] = 15;
        options[3, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[4, OPTION_NAME] = 'VIRIDIAN VALLEY ZONE';
        options[4, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[4, OPTION_VALUE] = 16;
        options[4, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[5, OPTION_NAME] = 'DRIFTING DYNAMO ZONE';
        options[5, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[5, OPTION_VALUE] = 17;
        options[5, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[6, OPTION_NAME] = 'TIDAL TUBES ZONE';
        options[6, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[6, OPTION_VALUE] = 18;
        options[6, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[7, OPTION_NAME] = 'SUNKEN SAUCER ZONE';
        options[7, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[7, OPTION_VALUE] = false;
        options[7, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[8, OPTION_NAME] = 'PLANETARY PANIC ZONE';
        options[8, OPTION_TYPE] = OPTION_TYPE_SUBMENU;
        options[8, OPTION_VALUE] = 19;
        options[8, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[9, OPTION_NAME] = 'GALACNIK GAUNTLET ZONE';
        options[9, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[9, OPTION_VALUE] = false;
        options[9, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[10, OPTION_NAME] = 'BACK';
        options[10, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[10, OPTION_VALUE] = 11;
        options[10, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        break;
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
        var title = '';
        switch(state)
        {
            case 13:
                title = 'ATTRACTION ATTACK ZONE';
                break;
            case 14:
                title = 'RAGING RUINS ZONE';
                break;
            case 15:
                title = 'FRIGID FORTRESS ZONE';
                break;
            case 16:
                title = 'VIRIDIAN VALLEY ZONE';
                break;
            case 17:
                title = 'DRIFTING DYNAMO ZONE';
                break;
            case 18:
                title = 'TIDAL TUBES ZONE';
                break;
        }
        options[0, OPTION_NAME] = title+'  ACT SELECT';
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[1, OPTION_NAME] = 'ACT 1 FUTURE';
        options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[1, OPTION_VALUE] = false;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[2, OPTION_NAME] = 'ACT 1 PAST';
        options[2, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[2, OPTION_VALUE] = false;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[3, OPTION_NAME] = 'ACT 2 FUTURE';
        options[3, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[3, OPTION_VALUE] = false;
        options[3, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[4, OPTION_NAME] = 'ACT 2 PAST';
        options[4, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[4, OPTION_VALUE] = false;
        options[4, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[5, OPTION_NAME] = 'BACK';
        options[5, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[5, OPTION_VALUE] = 12;
        options[5, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        break;
    case 19:
        var title = 'PLANETARY PANIC ZONE';
        options[0, OPTION_NAME] = title+'  ACT SELECT';
        options[0, OPTION_TYPE] = OPTION_TYPE_TITLE;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        options[1, OPTION_NAME] = 'ACT 1';
        options[1, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[1, OPTION_VALUE] = false;
        options[1, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[2, OPTION_NAME] = 'ACT 2';
        options[2, OPTION_TYPE] = OPTION_TYPE_SIMPLE;
        options[2, OPTION_VALUE] = false;
        options[2, OPTION_ANIMATION] = OPTION_ANIMATION_LONGPRESS;
        options[3, OPTION_NAME] = 'BACK';
        options[3, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[3, OPTION_VALUE] = 12;
        options[3, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        break;
    default:
        options[0, OPTION_NAME] = 'STATE DOES NOT EXIST';
        options[0, OPTION_TYPE] = OPTION_TYPE_RETURN;
        options[0, OPTION_VALUE] = false;
        options[0, OPTION_ANIMATION] = OPTION_ANIMATION_NONE;
        break;
        
}
// calculating the Y offset
max_cursor = array_height_2d(options) - 1;
menu_y_offset = floor((view_hview[view_current] - 20 * array_height_2d(options))/2);

options_initialized = true;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// step - called by parent object

if(active)
{
    // there is no such thing as default state - a default state must be a context-specific one
    if(state == 0)
    {
       state = default_state;
    }
    
    if(!options_initialized)
    {
        event_user(1);
    }
    if(wait_for_release)
    {
        if (input_check_released(cSTART))
        {
            wait_for_release = false;
        }
    }
    else
    {
        if(use_default_interface)
        {
            /*
            Here, this is the code responsible for how the menu
            regularly operates
            
            */
            if(cursor == 0)
            {
                // if it's a menu title, it's not supposed to be selectable
                if (options[0, OPTION_TYPE] == OPTION_TYPE_TITLE)
                {
                    cursor = 1;
                }
            }
            // Input is only allowed if no animation is playing
            allow_input = (flash_timer == 0) &amp;&amp; (slide_timer == 0) &amp;&amp; (delay_timer == 0);
            if(allow_input)
            {
                // moving up, looping if necessary, skipping the title if there's one
                if input_check_pressed(cUP) {
                    audio_play_sound(sndBeep,10,false);
                    cursor--;
                    if(cursor == 0)
                    {
                        if(options[0, OPTION_TYPE] == OPTION_TYPE_TITLE)
                        {
                            cursor = max_cursor;
                        }
                    }
                    if(cursor &lt; 0)
                    {
                        cursor = max_cursor;
                    }
                }
                
                // moving down, looping if necessary, skipping the title if there's one
                if input_check_pressed(cDOWN) {
                    audio_play_sound(sndBeep,10,false);
                    cursor++;
                    if(cursor &gt; max_cursor)
                    {
                        cursor = 0;
                        if(options[0, OPTION_TYPE] == OPTION_TYPE_TITLE)
                        {
                            cursor = 1;
                        }
                    }
                }
                
                // activating the seleted item
                if input_check_pressed(cACTION) || input_check_pressed(cSTART) {
                    event_user(5);
                }
                
                // if we want to cancel, the "back" menu item is found and activated
                if input_check_pressed(cCANCEL) {
                    for(var i = 0; i &lt; max_cursor; i++)
                    {
                        if(options[i, OPTION_TYPE] == OPTION_TYPE_RETURN)
                        {
                            cursor = i;
                            event_user(5);
                            break;
                        }
                    }
                }
            }
            else
            {
                if(flash_timer &gt; 0)
                {
                    // some items play a flashing animation before activating
                    flash_timer--;
                    if(flash_timer == 0)
                    {
                        event_user(2);
                    }
                }
                else
                if(slide_timer &gt; 0)
                {
                    // this is the animation that plays when sliding between option screens
                    slide_timer--;
                    if(slide_timer == 15)
                    {
                        state = slide_to_state;
                        cursor = slide_to_cursor;
                        event_user(1);
                        for(var i = 0; i &lt; max_cursor; i++)
                        {
                            if(options[i, OPTION_TYPE] == OPTION_TYPE_SUBMENU)
                            {
                                if(options[i, OPTION_VALUE] == slide_from_state)
                                {
                                    cursor = i;
                                }
                            }
                        }
                    }
                    var diffxperframe = view_wview[view_current] / 15;
                    if(slide_timer &gt; 15)
                    {
                        slide_x_shift = -1 * diffxperframe * (30 - slide_timer);
                    }
                    else
                    {
                        slide_x_shift = diffxperframe * slide_timer;
                    }
                    if(!slide_dir)
                    {
                        slide_x_shift *= -1;
                    }
                }
                else
                if(delay_timer &gt; 0)
                {
                    // this is just for the special stage failure menus where a title must be shown for a bit before the rest
                    delay_timer--;
                }
            }
        }
        else
        {

            if(slide_timer &gt; 0)
            {
                // this is the animation that plays when sliding between option screens
                slide_timer--;
                if(slide_timer == 15)
                {
                    state = slide_to_state;
                    cursor = slide_to_cursor;
                    event_user(1);
                    for(var i = 0; i &lt; max_cursor; i++)
                    {
                        if(options[i, OPTION_TYPE] == OPTION_TYPE_SUBMENU)
                        {
                            if(options[i, OPTION_VALUE] == slide_from_state)
                            {
                                cursor = i;
                            }
                        }
                    }
                }
                var diffxperframe = view_wview[view_current] / 15;
                if(slide_timer &gt; 15)
                {
                    slide_x_shift = -1 * diffxperframe * (30 - slide_timer);
                }
                else
                {
                    slide_x_shift = diffxperframe * slide_timer;
                }
                if(!slide_dir)
                {
                    slide_x_shift *= -1;
                }
            }
            allow_input = (flash_timer == 0) &amp;&amp; (slide_timer == 0) &amp;&amp; (delay_timer == 0);
            /*
            Some options require irregular GUI items or backing code
            This is where these options are coded
            */
            if(state == 8 || state == 9)
            {
                /*
                currently remapping keys on the keyboard (state 8)
                or buttons/axes on a gamepad (state 9)
                
                substate is basically:
                2 - remapping up
                3 - remapping down
                4 - remapping left
                5 - remapping right
                6 - remapping A
                7 - remapping B
                8 - remapping C
                9 - remapping START
                10 - dumping everything we've remapped so far to the configuration file
                
                if cursor is equal to substate, we are only remapping one button
                if cursor is 1, we're remapping everything
                pressing ESC (or a similar key on a different platform) cancels everything
                */
                if(substate &gt;= 2 &amp;&amp; substate &lt;= 9)
                {
                    var keyToMap = 0;
                    switch(substate)
                    {
                        case 2:
                             keyToMap = cUP;
                             break;
                        case 3:
                             keyToMap = cDOWN;
                             break;
                        case 4:
                             keyToMap = cLEFT;
                             break;
                        case 5:
                             keyToMap = cRIGHT;
                             break;
                        case 6:
                             keyToMap = cA;
                             break;
                        case 7:
                             keyToMap = cB;
                             break;
                        case 8:
                             keyToMap = cC;
                             break;
                        case 9:
                             keyToMap = cSTART;
                             break;
                    }
                    if(state == 8)
                    {
                        // Could have used keyboard_check_pressed, but it doesn't work correctly on all platforms.
                        // So instead, feist your eyes on this horror:
                        var pressed_key = -1;
                        for(var i = 1; i &lt;= 255; i++)
                        {
                            if(keyboard_check_pressed(i))
                            {
                                pressed_key = i;
                            }
                        }
                        if (pressed_key != -1) {
                            
                            if (pressed_key == objProgram.back_button)
                            {
                                // cancel key pressed - Abort! Abort! Abort! Return to the menu's usual operating mode
                                ds_map_destroy(temp_map);
                                temp_map = ds_map_create();
                                use_default_interface = true;
                                substate = 0;
                            }
                            else
                            {
                                var key = 0;
                                if(keyToMap &gt; 0)
                                {
                                    ds_map_add(temp_map, keyToMap, pressed_key);
                                }
                                if(substate == cursor)
                                {
                                    substate = 10;
                                }
                                else
                                {
                                    substate++;
                                }
                            }
                            event_user(1);
                        }
                    }
                    else
                    if(state == 9)
                    {
                        // remapping up on gamepad
                        if(keyboard_check_pressed(objProgram.back_button))
                        {
                            // cancel key pressed - Abort! Abort! Abort! Return to the menu's usual operating mode
                            // it's also present in this option, in case the player wants to remap the peripheral they don't have
                            // would hate to softlock the game, is all :)
                            ds_map_destroy(temp_map);
                            temp_map = ds_map_create();
                            use_default_interface = true;
                            substate = 0;
                            event_user(1);
                        }
                        else
                        {
                            var mapped = false;
                            var padButton = input_any_gamepad_button()
                            if padButton { 
                                ds_map_add(temp_map, keyToMap, padButton);
                                mapped = true;
                            }
                            if(wait_for_release_axis)
                            {
                                axis = input_any_gamepad_axis();
                                if(axis == "")
                                {
                                    wait_for_release_axis = false;
                                }
                            }
                            else
                            {
                                if(axis == "")
                                {
                                    axis = input_any_gamepad_axis();
                                }
                                if axis != "" {
                                    if input_any_gamepad_axis() == "" {
                                        // axes can only be mapped to directions
                                        if(keyToMap == cUP || keyToMap == cDOWN || keyToMap == cLEFT || keyToMap == cRIGHT)
                                        {
                                            ds_map_add(temp_map, keyToMap, axis);
                                            mapped = true;
                                        }
                                        wait_for_release_axis = true;
                                    }
                                }
                            }
                            if(mapped)
                            {
                                if(substate == cursor)
                                {
                                    substate = 10;
                                }
                                else
                                {
                                    substate++;
                                }
                                event_user(1);
                            }
                        }
                    }  
                }        
                else
                if(substate == 10)
                {
                    // and this is where everything is dumped to the configuration file and applied in-game
                    var size, key, i;
                    size = ds_map_size(temp_map);
                    key = ds_map_find_first(temp_map);
                    for (i = 0; i &lt; size; i++;)
                    {
                        if(key == cUP || key == cDOWN || key == cLEFT || key == cRIGHT || key == cA || key == cB || key == cC || key == cSTART)
                        {
                            var iniKey = "";
                            switch(key)
                            {
                                case cUP:
                                    iniKey = "up";
                                    break;
                                case cDOWN:
                                    iniKey = "down";
                                    break;
                                case cLEFT:
                                    iniKey = "left";
                                    break;
                                case cRIGHT:
                                    iniKey = "right";
                                    break;
                                case cA:
                                    iniKey = "a";
                                    break;
                                case cB:
                                    iniKey = "b";
                                    break;
                                case cC:
                                    iniKey = "c";
                                    break;
                                case cSTART:
                                    iniKey = "start";
                                    break;
                            }
                            if(iniKey != "")
                            {
                                if(state == 8)
                                {
                                    // save key for keyboard
                                   save_control_map_keyboard(iniKey,ds_map_find_value(temp_map, key));
                                }
                                else
                                if(state == 9)
                                {
                                    // save for gamepad
                                   save_control_map_gamepad(iniKey,ds_map_find_value(temp_map, key));
                                }
                            }
                        }
                        key = ds_map_find_next(temp_map, key);
                    }
                    // everything's dumped? good! Let's now apply it and go back to the menu's regular operations
                    with objInput input_load();
                    wait_for_release = false;
                    ds_map_destroy(temp_map);
                    temp_map = ds_map_create();
                    use_default_interface = true;
                    substate = 0;
                    event_user(1);
                }
                else
                {
                    wait_for_release = false;
                    substate = 0;
                    ds_map_destroy(temp_map);
                    temp_map = ds_map_create();
                    use_default_interface = true;
                    event_user(1);
                }
            }
            else
            if(state == 11)
            {
                // cursor: 7 - back, 8 - tails, 9 - sonic, 10 - knuckles
                allow_input = (flash_timer == 0) &amp;&amp; (slide_timer == 0) &amp;&amp; (delay_timer == 0);
                if(allow_input)
                {
                    if input_check_pressed(cUP) || input_check_pressed(cDOWN) {
                        if(cursor == 5)
                        {
                            cursor = 9;
                        }
                        else
                        {
                            cursor = 5;
                        }
                        audio_play_sound(sndBeep,10,false);
                    }
                    if input_check_pressed(cLEFT) {
                        if(cursor != 5)
                        {
                            cursor--;
                            if(cursor == 7)
                            {
                                cursor = 10;
                            }
                        }
                        audio_play_sound(sndBeep,10,false);
                    }
                    if input_check_pressed(cRIGHT) {
                        if(cursor != 5)
                        {
                            cursor++;
                            if(cursor == 11)
                            {
                                cursor = 8;
                            }
                        }
                        audio_play_sound(sndBeep,10,false);
                    }
                    // activating the seleted item
                    if input_check_pressed(cACTION) || input_check_pressed(cSTART) {
                        event_user(5);
                    }
                    
                    // if we want to cancel, the "back" menu item is found and activated
                    if input_check_pressed(cCANCEL) {
                        active = false;
                    }
                }
            }
        }
    }
    flash_on = !flash_on;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
