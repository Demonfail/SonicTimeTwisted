<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1025</depth>
  <persistent>-1</persistent>
  <parentName>objTransition</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>611</id>
        <kind>6</kind>
        <userelative>-1</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>mode</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>1</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>611</id>
        <kind>6</kind>
        <userelative>-1</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>facing</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>objProgram.time_traveling</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Setup Shader
/*
TIME TRAVEL EFFECT
This effect is achieved by drawing an animation (in this case, a scaled sprite) to a surface.
This results in a white on transparent image on the surface. When the surface is drawn with the TimeTravelShader applied,
the white pixels will be replaced with a texture that makes it look like the SCD time travel effect.
*/
// send some information to the shader; the shader has to be set for this to work
// (I don't know if this can be screwed up by using other shaders; if so, this info might have to be sent in the draw event...)
shader_set(TimeTravelShader);
// send: the scaling of the sparkly SCD texture so it will repeat enough times to not be stretched
shader_set_uniform_f(shader_get_uniform(TimeTravelShader, "scl"), 426 / background_get_width(tt_texture), 240 / background_get_height(tt_texture));
// send: the texture index of the sparkly SCD texture
texture_set_stage(shader_get_sampler_index(TimeTravelShader, "mask"), background_get_texture(tt_texture));
// send: the texture index of the the gradient used to cycle the colours
texture_set_stage(shader_get_sampler_index(TimeTravelShader, "grad"), background_get_texture(tt_gradient));
shader_reset();
// create a surface the size of the screen to draw the effect on
tt_surface = surface_create(426, 240);
// I've included two types of "zipper animation" - see step event
type = false;
// the image index of the animated sprite that will be drawn to the texture
image_index = 0;
image_speed = 0;
// the amount to shift the gradient to cycle the colours; starts at 0
// it's also used to slide the texture horizontally to give it some motion, but you could use a 2nd value
// if the speeds need to be tweaked
shift = 0;
// the parameter handle to be used to send the shift amount to the shader later in the draw event
param_shift = shader_get_uniform(TimeTravelShader, "shift");
image_xscale=2*facing;
image_yscale=2;
spr=sprTimeTravelEffect;
if image_xscale == -2 {
   xoffset=426;
} else xoffset=0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
/// Get transition mode
switch mode
{
case 1: // wipe out
    if (image_index &gt; 32 )
    {
        if next_room&gt;-1 room_goto(next_room);
        mode = 0;
        break;
    }
        image_index += .5;
    break;
case 0: // start level
    objLevel.started = true;
    objLevel.timer_enabled = true;
    with objHud visible = true;
    mode = -1;
    //xoffset=426;
    image_xscale = image_xscale*-1;
    
    if image_xscale == -2 {
       xoffset=426;
    } else xoffset=0;
    break;
case -1: // wipe in
    if (image_index &lt;= 0) {instance_destroy(); break;}
        image_index -= .5;
    break;
}

if !surface_exists(tt_surface)
    tt_surface = surface_create(426, 240);
// set the drawing target to the surface
surface_set_target(tt_surface);
// clear the surface
draw_clear_alpha(0, 0);
// draw the sprite mirrored on the y axis to create the zipper shape
draw_sprite_ext(spr, floor(image_index), 0, 0, 2, 2, 0, c_white, 1);
draw_sprite_ext(spr, floor(image_index), 0, 120, 2, -2, 0, c_white, 1);
// reset the drawing target to the screen
surface_reset_target();
// increase the shift amount; this will cycle the colours
shift += 0.01;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
// draw a dummy background for the effect to cover
//draw_background_ext(zonebkg, 0, 0, 2, 2, 0, c_white, 1);
// turn on the time travel effect shader
shader_set(TimeTravelShader);
// send the shift amount (for colour cycling) to the shader
shader_set_uniform_f(param_shift, shift);
// draw the surface with the zipper animation on it
// (here it's scaled by 2 just to see it better)
draw_surface_ext(tt_surface, view_xview+xoffset, view_yview, image_xscale, image_yscale, 0, c_white, 1);
// turn off the shader
shader_reset();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
