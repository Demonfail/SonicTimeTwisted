<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>grid_width = 512;
grid_height = 256;
x_in_grid = -1;
y_in_grid = -1;
view_id = 0;
x_in_grid_max = ceil(room_width/grid_width);
y_in_grid_max = ceil(room_height/grid_height);

// list of renderers
tile_grid_renderers = ds_map_create();

// could have managed this as a 3D array of sorts... at this point, using a map with strings containing the three indexes as strings is easier
// all tiles will be grouped by: X of the grid cell x Y of the grid cell x depth
tiles = ds_map_create();

// Divide all tiles into groups and fit them into the grid, then hide them from view
var tiles_count = tile_get_count();
for(var i = 0; i &lt; tiles_count; i++)
{
    var tile_id = tile_get_id(i);
    var tx = tile_get_x(tile_id);
    var ty = tile_get_y(tile_id);
    if(
        (!background_exists(tile_get_background(tile_id)))
        ||
        (tile_get_width(tile_id) + tx &lt; 0 || tx &gt; room_width)
        ||
        (tile_get_height(tile_id) + ty &lt; 0 || ty &gt; room_height)
        ||
        (tile_get_alpha(tile_id) == 0)
    )
    {
        continue;
    }
    
    var d = tile_get_depth(tile_id);
    if(!ds_map_exists(tile_grid_renderers, d))
    {
        var d_renderer = instance_create(x,y,objTileGridRenderer);
        d_renderer.use_depth = d;
        d_renderer.depth = d; // two different variables, just in case
        d_renderer.view_id = view_id;
        d_renderer.owner = id;
        ds_map_add(tile_grid_renderers, d, d_renderer);
    }
    
    // detect which grid cell this tile belongs to, if at all (some tiles can be off screen)
    var gridCellX = tx div grid_width;
    var gridCellY = ty div grid_height;
    if(gridCellX &gt;= 0 &amp;&amp; gridCellX &lt; x_in_grid_max &amp;&amp; gridCellY &gt;= 0 &amp;&amp;  gridCellY &lt; y_in_grid_max)
    {
        var key = string(gridCellX)+'|'+string(gridCellY)+'|'+string(d);
        if(!ds_map_exists(tiles, key))
        {
            var newArray = false;
            newArray[0] = tile_id;
            ds_map_add(tiles, key, newArray);
        }
        else
        {
            var newArray = ds_map_find_value(tiles, key);
            newArray[array_length_1d(newArray)] = tile_id;
            ds_map_replace(tiles, key, newArray);
        }
    }
    tile_set_visible(tile_id, false);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// cleanup at map end
/*
for(var i = 0; i &lt; ds_grid_width(grid); i++)
{
    for(var j = 0; j &lt; ds_grid_height(grid); j++)
    {
        ds_list_destroy(grid_index[# i, j]);
    }
}
ds_grid_destroy(grid);
*/
ds_map_destroy(tile_grid_renderers);
ds_map_destroy(tiles);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var current_x_position = view_xview[view_id] div grid_width;
var current_y_position = view_yview[view_id] div grid_height;
if(current_x_position != x_in_grid || current_y_position != y_in_grid)
{
    // if the view has moved from one grid cell to another, reinitialize the currently draw tiles
    
    // move to the new location for the drawing
    x_in_grid = current_x_position;
    y_in_grid = current_y_position;
    
    x = x_in_grid * grid_width;
    y = y_in_grid * grid_height;
    
    // initialize grid renderers for the current grid cell and the 8 surrounding ones
    var map_size = ds_map_size(tile_grid_renderers);
    var map_key = ds_map_find_first(tile_grid_renderers);
    for(var i = 0; i &lt; map_size; i++)
    {
        // the key is in fact the depth
        // place the object containing the surface to draw relatively off screen
        var renderer = ds_map_find_value(tile_grid_renderers, map_key);
        renderer.x = x - grid_width;
        renderer.y = y - grid_height;
        // force redrawing of the tiles
        if(surface_exists(renderer.s))
        {
            surface_free(renderer.s);
        }
        map_key = ds_map_find_next(tile_grid_renderers, map_key);
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
